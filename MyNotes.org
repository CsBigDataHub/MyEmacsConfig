* Emacs Notes

** Symbola Font
 https://web.archive.org/web/20191029215733/users.teilar.gr/~g1951d/Symbola.zip

** movement

| keys                    | Movements                                                                                      |
|-------------------------+------------------------------------------------------------------------------------------------|
| C-a                     | Move to beginning of line.                                                                     |
| M-m                     | Move to first non-whitespace character on the line.                                            |
| C-e                     | Move to end of line.                                                                           |
| C-f                     | Move forward one character.                                                                    |
| C-b                     | Move backward one character.                                                                   |
| M-f                     | Move forward one word (I use this a lot).                                                      |
| M-b                     | Move backward one word (I use this a lot, too).                                                |
| C-s                     | Regex search for text in current buffer and move to it. Press C-s again to move to next match. |
| C-r                     | Same as C-s, but search in reverse.                                                            |
| M-<                     | Move to beginning of buffer.                                                                   |
| M->                     | Move to end of buffer.                                                                         |
| M-g g                   | Go to line.                                                                                    |
| C-n (n for Next)        | Moving to the next line                                                                        |
| C-p (p for Previous)    | Moving to the previous line                                                                    |
| C-f (f for Forward)     | Moving one character forward                                                                   |
| C-b (b for Backward)    | Moving one character backward                                                                  |
| M-f (f for Forward)     | Moving one word forward                                                                        |
| M-b (b for Backward)    | Moving one word backward                                                                       |
| C-a                     | Moving to the start of a line                                                                  |
| C-e (e for End)         | Moving to the end of a line                                                                    |
| M-a                     | Moving to the start of a sentence                                                              |
| M-e (e for End)         | Moving to the end of a sentence                                                                |
| C-v (or PgDn)           | Moving one page down                                                                           |
| M-v (or PgUp)           | Moving one page up                                                                             |
| M-< (Alt + Shift + "<") | Moving to the beginning of the file                                                            |
| M-> (Alt + Shift + ">") | Moving to the end of the file                                                                  |
| C-u C-SPC               | go to previous cursor position of the same buffer                                              |
| C-x C-SPC               | go to previous cursor position between buffers                                                                                       |

** Mark

| keys              | description |
|-------------------+-------------|
| C-SPC             | set mark    |
| mark-paragraph    | M-h         |
| mark-sexp         | C-M-SPC     |
| mark-whole-buffer | C-x h       |
| mark-word         | M-@         |

** Copy/Paste

| Keys                    | Description                                              |
|-------------------------+----------------------------------------------------------|
| C-w                     | Kill region.                                             |
| M-w                     | Copy region to kill ring.                                |
| C-y                     | Yank.                                                    |
| M-y                     | Cycle through kill ring after yanking.                   |
| M-d                     | Kill word.                                               |
| C-k                     | Kill line.                                               |
| C-u o w [In dired mode] | [In dired-mode] To copy the file name at point with path |
| w [In dired mode]       | [In dired mode] to copy file name at point               |

** Delete Text

| Keys        | Description            |
|-------------+------------------------|
| C-d         | Delete a character     |
| M-d         | Delete a word forward  |
| M-BackSpace | Delete a word backward |
|             |                        |

** Case Conversion Commands

| keys    | Description                                           |
|---------+-------------------------------------------------------|
| M-l     | Convert following word to lower case (downcase-word). |
| M-u     | Convert following word to upper case (upcase-word).   |
| M-c     | Capitalize the following word (capitalize-word).      |
| C-x C-l | Convert region to lower case (downcase-region).       |
| C-x C-u | Convert region to upper case (upcase-region).         |
|         |                                                       |

** Window Operation

| Keys  | Description                                  |
|-------+----------------------------------------------|
| C-x 2 | split-window-below (vertically)              |
| C-x 3 | split-window-right (horizontally)            |
| C-x 0 | delete-window (this one)                     |
| C-x 1 | delete-other-windows                         |
| C-x o | other-window (moves foxus to the next window |
| C-x + | balace-windows                               |
|       |                                              |

** pdf-tools
| Navigation                                 |                   |
|--------------------------------------------+-------------------|
| Scroll Up / Down by page-full              | ~space~ / ~backspace~ |
| Scroll Up / Down by line                   | ~C-n~ / ~C-p~         |
| Scroll Right / Left                        | ~C-f~ / ~C-b~         |
| Top of Page / Bottom of Page               | ~<~ / ~>~             |
| Next Page / Previous Page                  | ~n~ / ~p~             |
| First Page / Last Page                     | ~M-<~ / ~M->~         |
| Incremental Search Forward / Backward      | ~C-s~ / ~C-r~         |
| Occur (list all lines containing a phrase) | ~M-s o~             |
| Jump to Occur Line                         | ~RETURN~            |
| Pick a Link and Jump                       | ~F~                 |
| Incremental Search in Links                | ~f~                 |
| History Back / Forwards                    | ~B~ / ~N~             |
| Display Outline                            | ~o~                 |
| Jump to Section from Outline               | ~RETURN~            |
| Jump to Page                               | ~M-g g~             |

| Display                                  |           |
|------------------------------------------+-----------|
| Zoom in / Zoom out                       | ~+~ / ~-~     |
| Fit Height / Fit Width / Fit Page        | ~H~ / ~W~ / ~P~ |
| Trim margins (set slice to bounding box) | ~s b~       |
| Reset margins                            | ~s r~       |
| Reset Zoom                               | 0         |

| Annotations                   |           |
|-------------------------------+-----------|
| List Annotations              | ~C-c C-a l~ |
| Jump to Annotations from List | ~SPACE~     |
| Mark Annotation for Deletion  | ~d~         |
| Delete Marked Annotations     | ~x~         |
| Unmark Annotations            | ~u~         |
| Close Annotation List         | ~q~         |

| Syncing with Auctex              |           |
|----------------------------------+-----------|
| jump to PDF location from source | ~C-c C-g~   |
| jump source location from PDF    | ~C-mouse-1~ |

| Miscellaneous                                 |         |
|-----------------------------------------------+---------|
| Refresh File (e.g., after recompiling source) | ~g~       |
| Print File                                    | ~C-c C-p~ |
|                                               |         |

** Search Repalce

| Keys | Description             |
|------+-------------------------|
| C-s  | Start a forward search. |
| C-r  | Start a reverse search. |
| M-%  | Query-replace           |

** Undo / Redo

| Keys  | Description |
|-------+-------------|
| C-x u | Undo        |
| C-_   | Undo        |
| C-/   | Undo        |
| C-S-/ | Redo        |
|       |             |

** Clojure

| Keys        | Description                                                                       |
|-------------+-----------------------------------------------------------------------------------|
| C-c M-n     | Switch to namespace of current buffer.                                            |
| C-x C-e     | Evaluate expression immediately preceding point.                                  |
| C-c C-k     | Compile current buffer.                                                           |
| C-c C-d C-d | Display documentation for symbol under point.                                     |
| M-. and M-, | Navigate to source code for symbol under point and return to your original buffer |
| C-c C-d C-a | Apropros search; find arbitrary text across function names and documentation.     |

** Cider REPL

| Keys         | Des                             |
|--------------+---------------------------------|
| C-up, C-down | Cycle through REPL history.     |
| C-enter      | Close parentheses and evaluate. |

** ParEdit-Mode

| Keys             | Description                                                             |
|------------------+-------------------------------------------------------------------------|
| C-right          | Slurp; move closing parenthesis to the right to include nextexpression. |
| C-left           | Barf; move closing parenthesis to the left to exclude lastexpression.   |
| C-M-f            | Move to the opening/closing parenthesis.                                |
| C-M-b            | Move to the opening/closing parenthesis.                                |
| M-(              | Surround expression after point in parentheses(paredit-wrap-round).     |
| M-x paredit-mode | Toggle paredit mode                                                     |
|                  |                                                                         |

** counsel-find-file

| keys    | Desc                               |
|---------+------------------------------------|
| //      | when on remote, cd to remote root. |
| / C-j   | select local root.                 |
| ~       | when on remote, cd to remote home. |
| / C-j ~ | when on remote, cd to local home.  |
| M-o c   | copy file                          |
| M-o d   | dired                              |

** Ivy
| Keys | Desc                                                  |
|------+-------------------------------------------------------|
| M-i  | This will insert select item to minibuffer completion |
|      |                                                       |

** Unicode Insert

To insert a vertical bar into a table field, use =\vert= or, inside a word =abc\vert{}def=.

Source: Org-mode manual: The built-in table editor.

If =\vert= is not automatically converted to |, call =org-toggle-pretty-entities=
per:

    =C-c C-x \=

    Toggle display of entities as UTF-8 characters. This does not change the
    buffer content which remains plain ASCII, but it overlays the UTF-8
    character for display purposes only.

Source: Org-mode manual: Special symbols

The function =org-toggle-pretty-entities= was introduced in version 7.01. Call
org-version and upgrade Org-mode if necessary.


| Key       | Character | Key     | Character | Key     | Character | Key         | Character |
|-----------+-----------+---------+-----------+---------+-----------+-------------+-----------|
| C-q M-SPC | NBSP      | C-q M-8 | ¸         | C-q M-P | Ð         | C-q M-h     | è         |
| C-q M-!   | ¡         | C-q M-9 | ¹         | C-q M-Q | Ñ         | C-q M-i     | é         |
| C-q M-"   | ¢         | C-q M-: | º         | C-q M-R | ò         | C-q M-j     | ê         |
| C-q M-#   | £         | C-q M-; | »         | C-q M-S | Ó         | C-q M-k     | ë         |
| C-q M-%   | ¥         | C-q M-= | ½         | C-q M-U | Õ         | C-q M-m     | í         |
| C-q M-’   | §         | C-q M-? | ¿         | C-q M-W | ×         | C-q M-o     | ï         |
| C-q M-(   | ¨         | C-q M-@ | À         | C-q M-X | Ø         | C-q M-p     | ð         |
| C-q M-)   | ©         | C-q M-A | Á         | C-q M-Y | Ù         | C-q M-q     | ñ         |
| C-q M-*   | ª         | C-q M-B | Â         | C-q M-Z | Ú         | C-q M-r     | ò         |
| C-q M-+   | «         | C-q M-C | Ã         | C-q M-[ | Û         | C-q M-s     | ó         |
| C-q M--   |           | C-q M-E | Å         | C-q M-] | Ý         | C-q M-u     | õ         |
| C-q M-.   | ®         | C-q M-F | Æ         | C-q M-^ | Þ         | C-q M-v     | ö         |
| C-q M-/   | ¯         | C-q M-G | Ç         | C-q M-_ | ß         | C-q M-w     | ÷         |
| C-q M-1   | ±         | C-q M-I | É         | C-q M-a | á         | C-q M-y     | ù         |
| C-q M-2   | ²         | C-q M-J | Ê         | C-q M-b | â         | C-q M-z     | ú         |
| C-q M-3   | ³         | C-q M-K | Ë         | C-q M-c | ã         | C-q M-}     | ý         |
| C-q M-4   | ´         | C-q M-L | Ì         | C-q M-d | ä         | C-q M-\vert | ü         |
| C-q M-5   | µ         | C-q M-M | Í         | C-q M-e | å         | C-q M-~     | þ         |
| C-q M-6   | ¶         | C-q M-N | Î         | C-q M-f | æ         | C-q M-{     | û         |
| C-q M-7   | ·         | C-q M-O | Ï         | C-q M-g | ç         |             |           |

** Org-Mode

| Keys           | Desc                           |
|----------------+--------------------------------|
| S-<right>      | mark as TODO or DONE           |
| C-c C-c        | Tag the bulltes                |
| M-x org-agenda | filter through tags and todo's |
|                |                                |
|                |                                |

** Convert tabs to space

- To replace tabs with the appropriate number of spaces, use M-x untabify.

- To do the reverse and convert multiple spaces to tabs, you can use M-x tabify.

- Both commands work on a region. To run on the whole buffer use a prefix argument (i.e. C-u M-x untabify).

** Sunraise commander
#+begin_src emacs-lisp

(setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                         ("melpa" . "https://melpa.org/packages/")
                         ("SC" . "http://joseito.republika.pl/sunrise-commander/")))


(add-to-list 'load-path "~/.emacs.d/local/sunrise-commander")

(require 'sunrise)
(require 'sunrise-modeline)
(require 'sunrise-tree)

(add-to-list 'auto-mode-alist '("\\.srvm\\'" . sr-virtual-mode))

https://medium.com/@enzuru/sunrise-commander-an-orthodox-file-manager-for-emacs-2f92fd08ac9e





(use-package sunrise-commander
  :ensure nil
  :after quelpa-use-package
  :quelpa (sunrise-commander :fetcher github :repo "escherdragon/sunrise-commander"))

;; ---( sunrise-commander )--------------------------------------------------------------


(use-package sunrise-commander
  :bind (("C-c j" . my-activate-sunrise)
         ("C-c C-j" . sunrise-cd))
  :commands sunrise
  :defines sr-tabs-mode-map
  :preface
  (defun my-activate-sunrise ()
    (interactive)
    (let ((sunrise-exists
           (loop for buf in (buffer-list)
                 when (string-match " (Sunrise)$" (buffer-name buf))
                 return buf)))
      (if sunrise-exists
          (call-interactively 'sunrise)
        (sunrise "~/dl/" "~/Archives/"))))
  :config
  (require 'sunrise-x-modeline)
  (require 'sunrise-x-tree)
  (require 'sunrise-x-tabs)
  (bind-key "/" 'sr-sticky-isearch-forward sr-mode-map)
  (bind-key "<backspace>" 'sr-scroll-quick-view-down sr-mode-map)
  (bind-key "C-x t" 'sr-toggle-truncate-lines sr-mode-map)
  (bind-key "q" 'sr-history-prev sr-mode-map)
  (bind-key "z" 'sr-quit sr-mode-map)
  (unbind-key "C-e" sr-mode-map)
  (unbind-key "C-p" sr-tabs-mode-map)
  (unbind-key "C-n" sr-tabs-mode-map)
  (unbind-key "M-<backspace>" sr-term-line-minor-mode-map)
  (bind-key "M-[" 'sr-tabs-prev sr-tabs-mode-map)
  (bind-key "M-]" 'sr-tabs-next sr-tabs-mode-map)
  (defun sr-browse-file (&optional file)
    "Display the selected file with the default appication."
    (interactive)
    (setq file (or file (dired-get-filename)))
    (save-selected-window
      (sr-select-viewer-window)
      (let ((buff (current-buffer))
            (fname (if (file-directory-p file)
                       file
                     (file-name-nondirectory file)))
            (app (cond
                  ((eq system-type 'darwin) "open %s")
                  ((eq system-type 'windows-nt) "open %s")
                  (t "xdg-open %s"))))
        (start-process-shell-command "open" nil (format app file))
        (unless (eq buff (current-buffer))
          (sr-scrollable-viewer (current-buffer)))
        (message "Opening \"%s\" ..." fname))))
  (defun sr-goto-dir (dir)
    "Change the current directory in the active pane to the given one."
    (interactive (list (progn
                         (require 'lusty-explorer)
                         (lusty-read-directory))))
    (if sr-goto-dir-function
        (funcall sr-goto-dir-function dir)
      (unless (and (eq major-mode 'sr-mode)
                   (sr-equal-dirs dir default-directory))
        (if (and sr-avfs-root
                 (null (posix-string-match "#" dir)))
            (setq dir (replace-regexp-in-string
                       (expand-file-name sr-avfs-root) "" dir)))
        (sr-save-aspect
         (sr-within dir (sr-alternate-buffer (dired dir))))
        (sr-history-push default-directory)
        (sr-beginning-of-buffer)))))

#+end_src
** Magit Cheatsheet
You might also be interested in the [[https://magit.vc/manual/magit-refcard.pdf][Magit Reference Card]] (pdf).

Magit video tutorial - https://www.youtube.com/watch?v=vQO7F2Q9DwA
                       https://www.youtube.com/watch?v=j-k-lkilbEs
                       https://www.youtube.com/watch?v=7ywEgcbaiys
                       https://www.youtube.com/watch?v=qXgGtyjXPiw

***  Section commands

These commands are for navigation and to change the visibility of
sections.

| Key                        | Description                                                       |
|----------------------------+-------------------------------------------------------------------|
| ~TAB~                      | toggle body of current section                                    |
| ~C-<tab>~                  | cycle visibility of current section and its children              |
| ~M-<tab>~                  | cycle visibility of all diff sections                             |
| ~s-<tab>~                  | cycle visibility of all sections                                  |
| ~1~, ~2~, ~3~, ~4~         | show surrounding sections up to level N, hide deeper levels       |
| ~M-1~, ~M-2~, ~M-3~, ~M-4~ | globally show sections up to level N, hide deeper levels          |
| ~^~                        | goto parent section                                               |
| ~p~                        | goto beginning of section, from there to previous section         |
| ~n~                        | goto next section                                                 |
| ~M-p~                      | goto beginning of section, from there to previous sibling section |
| ~M-n~                      | goto next sibling section                                         |

***  Buffer commands

| Key     | Description                                                                     |
|---------+---------------------------------------------------------------------------------|
| ~g~     | refresh current buffer and status buffer, possibly revert file-visiting buffers |
| ~G~     | refresh all Magit buffers and revert all file-visiting buffers in repository    |
| ~q~     | bury the current Magit buffer, restoring previous window configuration          |
| ~C-u q~ | kill the current Magit buffer, restoring previous window configuration          |

***  Various common commands

| Key   | Description                                   |
|-------+-----------------------------------------------|
| ~SPC~ | scroll up (1)                                 |
| ~DEL~ | scroll down (1)                               |
| ~RET~ | show the thing at point in another buffer (2) |
| ~j~   | jump somewhere (3)                            |
| ~$~   | show output of recent calls to git            |

- (1) In most Magit buffers this scrolls the current buffer.
  In log buffers this instead scrolls the diff buffer shown
  in another window.
- (2) What is being shown depends on the context.
- (3) Where this jumps to depends on the context.

***  Various assorted commands

| Key     | Description                   |
|---------+-------------------------------|
| ~i~     | add a gitignore rule globally |
| ~I~     | add a gitignore rule locally  |
| ~x~     | reset using ~--mixed~         |
| ~C-u x~ | reset using ~--hard~          |

***  Prefix commands

You can use these when you're in the ~magit-status~ buffer. The list below can also be accessed by pressing ~h~, so there's no need to memorize this wiki page. Commands will open popup buffers listing infix arguments and suffix commands.

| Key   | Description          |
|-------+----------------------|
| ~A~     | cherry-pick          |
| ~b~     | branch               |
| ~B~     | bisect               |
| ~c~     | commit               |
| ~d~     | diff                 |
| ~E~     | ediff                |
| ~f~     | fetch                |
| ~F~     | pull                 |
| ~h~, ~?~  | show popup of popups |
| ~l~     | log                  |
| ~m~     | merge                |
| ~M~     | remote               |
| ~o~     | submodule            |
| ~P~     | push                 |
| ~r~     | rebase               |
| ~t~     | tag                  |
| ~T~     | note                 |
| ~V~     | revert               |
| ~w~     | apply patches        |
| ~C-u y~ | list refs (1)        |
| ~z~     | stash                |
| ~!~     | run git or gui tool  |

- (1) Actually ~y~ is bound to a popup/prefix command, but it is one of
  the few popups which default to a suffix command and therefore has to
  be called with a prefix argument to actually show the popup buffer.

***  Applying changes

| Key | Description                    |
|-----+--------------------------------|
| ~a~   | apply the change at point      |
| ~k~   | discard the change at point    |
| ~s~   | stage the change at point      |
| ~S~   | stage all unstaged changes     |
| ~u~   | unstage the change at point    |
| ~U~   | unstage all staged changes (1) |
| ~v~   | reverse the change at point    |

- (1) Actually this asks for a commit to reset the index too.  If you
  just press ~RET~, then what this equivalent to unstaging everything.
  If that is too confusing then just bind this key to ~magit-unstage-all~.

***  Diffing

These commands show diffs or manipulate the diff arguments used to
generate the diffs in the current buffer.

| Key   | Description                                   |
|-------+-----------------------------------------------|
| ~RET~ | (on commit) show commit                       |
| ~RET~ | (on stash) show stash                         |
| ~d~   | show diffing popup                            |
| ~D~   | show popup for changing diff arguments        |
| ~e~   | use ediff to stage, compare, or stage (dwim)  |
| ~E~   | show ediffing popup (for when dwimming fails) |
| ~+~   | show more context lines                       |
| ~-~   | show less context lines                       |
| ~0~   | show default amount of context lines (three)  |

***  Rebasing

The following commands can be used from the ~magit-rebase-popup~ which is activated using ~r~

| Key   | Description                                   |
|-------+-----------------------------------------------|
| ~i~   | Start an interactive rebase sequence.         |
| ~f~   | Combine squash and fixup commits with their intended targets. |
| ~m~   | Edit a single older commit using rebase.      |
| ~w~   | Reword a single older commit using rebase.    |
| ~k~   | Remove a single older commit using rebase.    |

Whilst performing a rebase the following editing sequences are available.

| Key   | Description                                   |
|-------+-----------------------------------------------|
| ~C-c C-c~ | Finish the current editing session by returning with exit code 0. Git then uses the rebase instructions it finds in the file. |
| ~C-c C-k~ |Cancel the current editing session by returning with exit code 1. Git then forgoes starting the rebase sequence. |
| ~RET~   | Show the commit on the current line in another buffer and select that buffer. |
| ~SPC~   | Show the commit on the current line in another buffer without selecting that buffer. If the revision buffer is already visible in another window of the current frame, then instead scroll that window up. |
| ~DEL~   | Show the commit on the current line in another buffer without selecting that buffer. If the revision buffer is already visible in another window of the current frame, then instead scroll that window down. |
| ~p~     | Move to previous line.                      |
| ~n~     | Move to next line.                          |
| ~M-p~   | Move the current commit (or command) up.    |
| ~M-n~   | Move the current commit (or command) down.  |
| ~r~     | Edit message of commit on current line.     |
| ~e~     | Stop at the commit on the current line.     |
| ~s~     | Meld commit on current line into previous commit, and edit message. |
| ~f~     | Meld commit on current line into previous commit, discarding the current commit’s message. |
| ~k~     | Kill the current action line.               |
| ~c~     | Use commit on current line.                 |
| ~x~     | Insert a shell command to be run after the proceeding commit. |
| ~y~     | Read an arbitrary commit and insert it below current line. |
| ~C-x u~ | Undo some previous changes. Like undo but works in read-only buffers. |

If a rebase is already in progress then ~magit-rebase-popup~ offers the following commands.

| Key   | Description                                   |
|-------+-----------------------------------------------|
| ~r~   | Restart the current rebasing operation.       |
| ~s~   | Skip the current commit and restart the current rebase operation. |
| ~e~   | Edit the todo list of the current rebase operation. |
| ~a~   | Abort the current rebase operation, restoring the original branch. |
* find and replace in project

#+BEGIN_SRC

M-x rg-project
M-x wgrep-change-to-wgrep-mode

#+END_SRC

* Remove empty lines from buffer

http://xenodium.com/flushing-empty-lines-in-emacs/

#+BEGIN_SRC

M-x flush-lines RET ^$ RET

#+END_SRC
* Emacs counsel default search switches

Following up from Enhanced Emacs searching with counsel switches, rather than remembering silver searcher and ripgrep switches, we can use counsel's ivy-initial-inputs-alist to set these up as default visible switches.

#+BEGIN_SRC emacs-lisp
(push '(counsel-ag . "--file-search-regex '' -- ") ivy-initial-inputs-alist)
(push '(counsel-rg . "--glob '**' -- ") ivy-initial-inputs-alist)
#+END_SRC

The default switches stay out of the way in typical searches, but can be easily modified to include (or exclude) results matching specific file names.

* Emacs org block company completion

Back in 2015, I bound the "<" key to a hydra for quickly inserting org blocks. The idea came from Oleg's post on [[https://oremacs.com/2015/03/07/hydra-org-templates/][org-mode block templates in]]
[[https://oremacs.com/2015/03/07/hydra-org-templates/][Hydra]]. The suggested binding settled in my muscle memory without much effort.

Fast forward to Febrary 2019. I replaced the hydra with [[https://orgmode.org/manual/Easy-templates.html][org-insert-structure-template]] when org-try-structure-completion was removed from
org mode. No biggie, as I kept the same binding to "<" and hardly noticed the change.

Since my primary use-case for easy templates is inserting [[https://orgmode.org/manual/Working-with-source-code.html][source blocks]], I was keen to expedite choosing the source language as well as
inserting the source block itself.

Writing a small [[https://company-mode.github.io/][company mode]] completion backend fits my primary use-case pretty well.

company-org-block.gif

The company backend looks as follow (Warning: [[https://twitter.com/tpanum/status/1197772426072997888][Snippet needs Org v9.2]]):
#+begin_src emacs-lisp

(require 'map)
(require 'org)
(require 'seq)

(defvar company-org-block-bol-p t "If t, detect completion when at
begining of line, otherwise detect completion anywhere.")

(defvar company-org--regexp "<\\([^ ]*\\)")

(defun company-org-block (command &optional arg &rest ignored)
  "Complete org babel languages into source blocks."
  (interactive (list 'interactive))
  (cl-case command
    (interactive (company-begin-backend 'company-org-block))
    (prefix (when (derived-mode-p 'org-mode)
              (company-org-block--grab-symbol-cons)))
    (candidates (company-org-block--candidates arg))
    (post-completion
     (company-org-block--expand arg))))

(defun company-org-block--candidates (prefix)
  "Return a list of org babel languages matching PREFIX."
  (seq-filter (lambda (language)
                (string-prefix-p prefix language))
              ;; Flatten `org-babel-load-languages' and
              ;; `org-structure-template-alist', join, and sort.
              (seq-sort
               #'string-lessp
               (append
                (mapcar #'prin1-to-string
                        (map-keys org-babel-load-languages))
                (map-values org-structure-template-alist)))))

(defun company-org-block--template-p (template)
  (seq-contains (map-values org-structure-template-alist)
                template))

(defun company-org-block--expand (insertion)
  "Replace INSERTION with actual source block."
  (delete-region (point) (- (point) (1+ ;; Include "<" in length.
                                     (length insertion))))
  (if (company-org-block--template-p insertion)
      (company-org-block--wrap-point insertion
                                     ;; May be multiple words.
                                     ;; Take the first one.
                                     (nth 0 (split-string insertion)))
    (company-org-block--wrap-point (format "src %s" insertion)
                                   "src")))

(defun company-org-block--wrap-point (begin end)
  "Wrap point with block using BEGIN and END.  For example:
#+begin_BEGIN
  |
#+end_END"
  (insert (format "#+begin_%s\n" begin))
  (insert (make-string org-edit-src-content-indentation ?\s))
  ;; Saving excursion restores point to location inside code block.
  (save-excursion
    (insert (format "\n#+end_%s" end))))

(defun company-org-block--grab-symbol-cons ()
  "Return cons with symbol and t whenever prefix of < is found.
For example: \"<e\" -> (\"e\" . t)"
  (when (looking-back (if company-org-block-bol-p
                          (concat "^" company-org--regexp)
                        company-org--regexp)
                      (line-beginning-position))
    (cons (match-string-no-properties 1) t)))
#+end_src

To use, add the backend enable company-mode in org-mode:

#+BEGIN_SRC emacs-lisp
(add-to-list 'company-backends 'company-org-block)
(company-mode +1)
#+END_SRC

Updates

- Removed language-specific header logic (use [[https://www.orgmode.org/worg/org-contrib/babel/header-args.html][org-babel-default-header-args]] instead).
- Also completes non-source block templates from [[https://orgmode.org/manual/Easy-templates.html][org-structure-template-alist]].
- Source in my [[https://github.com/xenodium/dotsies/blob/master/emacs/ar/company-org-block.el][dot files]].
- Removed unnecessary binding. Just add company backend as usual.
- Thanks to [[https://twitter.com/takaxp][Takaaki Ishikawa]] for [[https://twitter.com/takaxp/status/1195884481535561729?s=20][suggesting `org-edit-src-content-indentation']].
- Thanks to [[https://twitter.com/tpanum][Thomas Kobber]] for [[https://twitter.com/xenodium/status/1194224168709083137][highlighting incompatibility]] with older org versions.

* A more reusable Emacs shell-command history

[[https://twitter.com/camdez][Cameron Desautel]] has a great post on [[https://engineering.collbox.co/post/working-faster-in-emacs-by-reading-the-future/][Working Faster in Emacs by Reading the "Future"]], highlighting M-n's usefulness for inserting
minibuffer default values.

Invoking M-n in shell-command's prompt is handy for quickly getting the current buffer's file name. This works great for one-off shell commands
like "chmod +x script.sh" or "tidy -xml -i -m data.xml". Unfortunately, these commands aren't easily reusable from shell-command's minibuffer
history, since it'll keep hardcoded file names.

There's likely existing built-in functionality or a more elaborate package for this, but advising read-shell-command enables us to write more
reusable commands like "chmod +x $f" or "tidy -xml -i -m $f". We merely replace $f with (buffer-file-name), and let everything else continue as
usual.



#+BEGIN_SRC emacs-lisp
(defun ar/adviced-read-shell-command (orig-fun &rest r)
  "Advice around `read-shell-command' to replace $f with buffer file name."
  (let ((command (apply orig-fun r)))
    (if (string-match-p "\\$f" command)
        (replace-regexp-in-string "\\$f"
                                  (or (buffer-file-name)
                                      (user-error "No file file visited to replace $f"))
                                  command)
      command)))

(advice-add 'read-shell-command
            :around
            'ar/adviced-read-shell-command)
#+END_SRC

It's worth mentioning that searching minibuffer history is pretty simple when leveraging [[https://github.com/abo-abo/swiper][counsel]] to fuzzy search (via
counsel-minibuffer-history, bound to C-r by default).

richer-shell-command-history.gif

On a final note, searching minibuffer history for cache hits is way more useful with richer history content. Be sure to save minibuffer history
across Emacs sessions and increase shell-command-history using the built-in [[https://www.emacswiki.org/emacs/SaveHist][savehist-mode]].

#+BEGIN_SRC emacs-lisp
(use-package savehist
  :custom
  (savehist-file "~/.emacs.d/savehist")
  (savehist-save-minibuffer-history t)
  (history-length 10000)
  (savehist-additional-variables
   '(shell-command-history))
  :config
  (savehist-mode +1))
#+END_SRC

* swiper and multiple cursors

Emacs [[https://github.com/abo-abo/swiper][swiper]] is awesome. I bound swiper-isearch to C-s. Also a big fan of [[https://github.com/magnars/multiple-cursors.el][multiple cursors]]. I use it regularly (it's fun).

I had totally missed Ole's post back in 2015: [[https://oremacs.com/2015/10/14/swiper-mc/][A simple multiple-cursors extension to swiper]]. Turns out, swiper has multiple cursors support
out of the box (bound to C-7 by default). Yay!

UPDATE: Thanks to [[https://irreal.org/blog/?p=8370][irreal's post]], please remember to add swiper-mc to mc/cmds-to-run-once list (or things won't work as expected). This
typically happens interactively when you invoke C-7 the first time around. Make sure you answer "n" when you see a prompt like:

swiper-mc-no.png

If you happen to choose "y" by mistake, take a look at ~/.emacs.d/.mc-lists.el to correct it. Remove swiper-mc from mc/cmds-to-run-for-all
and add it to mc/cmds-to-run-once. Invoke m-x eval-buffer to reset the values and you're good to go.

* Speeding up Emacs tramp via ControlMaster

Via [[https://gist.github.com/ralt/a36288cd748ce185b26237e6b85b27bb][Florian Margaine's Eshell config]], I discovered ssh's [[https://man.openbsd.org/ssh_config#ControlMaster][ControlMaster]]. It enables sharing multiple sessions over a single network
connection. This has the benefit of speeding up Emacs TRAMP.

In your ~/.ssh/config add:
#+begin_src sh
Host *
    ControlPath ~/.ssh/master-%h:%p
    ControlMaster auto
    ControlPersist 10m

#+end_src

* Tramp mode tricks

Emacs is amazing. It’s a very different sort of thing than a code text editor like Vim or an IDE like VSCode. It’s a different way of thinking of how
to interact with a computer, where you build up techniques on top of simple tricks that let you get amazing things done. Of course, part of the
appeal/challenge is that you need to figure out how to make it work yourself. Since there’s not much in the way of gentle tutorials, lets look at
what you can do with tramp to get a sense of what is possible.

Edit a file on a remote server

Lets say that you have a remote server named ssb.willschenk.com and you want to edit the /etc/hosts file. We can open that up directly in
emacs. The basic form for connecting to something using TRAMP is:

=C-x C-f /remotehost:filename RET (or /method:user@remotehost:filename)=

So, for example, if I type C-x C-f /ssh:root@ssb.willschenk.com:/etc/host= it connects over ssh to the remote server and edits that file. If I save
the file, copy and paste stuff, etc it will transparently sync the file over the network. We don’t need to install a text editor on this server, and
we’ll have all of our local configurations and copy and paste and all that stuff that we are used to. No installing vim for some quick configuration
file editing.



Directory browsing

=dired= mode also works, so if you want to move around just =C-x C-f= and select the directory, then you can navigate around as you
normally would.



Open a shell

M-x shell opens a shell with the current working directory of the active buffer. This also works if that is a remote file. If you use the C-u prefix
command, you can open a shell with the buffer’s name specified. This is handy if you have multiple things open at the same time.

C-u M-x shell will ask you want you want to name the buffer (I suggest the hostname), the starting directory which you be the /ssh... string, and
then the shell command to use, which I leave as /bin/bash. Now you are interacting over ssh to the remote server!

This also keeps track of which directory you are in, so if, inside of the shell you cd, emacs knows where you are. If you use the normal
keystrokes to open a file, C-x C-f it defaults to the directory that you are in on the remote server. TAB completion works in the minibuffer too!

Inside of shell mode you can use C-up and C-down to cycle through command history, all the normal things work.



Edit a file as root

Need to edit a file as a different user?

=C-x C-f /sudo::/etc/hosts=

TRAMP in this case is piping things through sudo rather an ssh, so we are making a remote connection to a different user on our computer.

Editing a file inside of a docker container

Another fun trick is to edit a file inside of a docker container. Is this what docker is used for? No, but it’s sometimes useful if you are debugging
a docker file or whatever and need a tigher feedback loop.

Inside of your .emacs
#+BEGIN_SRC emacs-lisp
;; Open files in Docker containers like so: /docker:drunk_bardeen:/etc/passwd
(push
 (cons
  "docker"
  '((tramp-login-program "docker")
    (tramp-login-args (("exec" "-it") ("%h") ("/bin/bash")))
    (tramp-remote-shell "/bin/sh")
    (tramp-remote-shell-args ("-i") ("-c"))))
 tramp-methods)

(defadvice tramp-completion-handle-file-name-all-completions
  (around dotemacs-completion-docker activate)
  "(tramp-completion-handle-file-name-all-completions \"\" \"/docker:\" returns
    a list of active Docker container names, followed by colons."
  (if (equal (ad-get-arg 1) "/docker:")
      (let* ((dockernames-raw (shell-command-to-string "docker ps | awk '$NF != \"NAMES\" { print $NF \":\" }'"))
             (dockernames (cl-remove-if-not
                           #'(lambda (dockerline) (string-match ":$" dockerline))
                           (split-string dockernames-raw "\n"))))
        (setq ad-return-value dockernames))
    ad-do-it))
#+END_SRC

To try this out, we can spin up a quick server like this

=docker run --rm -p 6379:6379 --name redis_container redis=

And then look at files inside of it using

=C-x C-f /docker:redis_container:/=

Which opens up a directory browser in the container. The tricks of open and editing the files are the same, and you can also open up a shell in
there to do what you need.

Now obviously one of the points of Docker is to ship code around that’s repeatably built, and this goes againsts the spirit of that. But if you
want to treat them as easily distrubuted virtual machines it’s very handy.

Inside a docker container on a remote host

We can also chain things together! Lets say that we have a docker container named ssb-pub running on a remote host ssb.willschenk.com, we
can connect to it using:

=C-x C-f /ssh:root@ssb.willschenk.com|docker:ssb-pub:/=

This works for file browsing as well as opening up a shell on the container.



It requires play

If you want to sit down and just start working on your project, the learning curve of emacs is too great. Its better to use a tool that’s already
configured and optimized for what you want to do. The Laravel from Scratch documentation, which is fabulous, recommends using PHP
Storm for people who are learning Laravel, since you can just get going and focus on solving your problem without going down the rabbit hole.
This is great. But sometimes its fun to go down the rabbit hole, and if you enjoy the playing the reward is great.

Emacs was first released in 1976 (take a look at the emacs timeline if you want to see the heritage in all it’s glory, though you’ll notice that it
ends at 2007, 13 years ago) and given that it’s been around for 44 years at this point, I think we can say that it’s not a fad. What you learn here
will be useful in the future no matter what the latest hot stuff is next.

References

1 https://www.emacswiki.org/emacs/TrampMode
2 https://www.emacswiki.org/emacs/TrampAndDocker
3 https://media.emacsconf.org/2019/23.html

* Editing Remote Code With Emacs
  :PROPERTIES:
  :CUSTOM_ID: editing-remote-code-with-emacs
  :CLASS: entry-title
  :END:

Lately, I've been working on a code-base situated remotely on a server
accessible over =ssh=. The network latency and size of the code
repository prompted me to reconsider the method to edit such files. I
discovered a few options I could use and finally settled with one of
them.

*** Option I : Running Emacs remotely.
    :PROPERTIES:
    :CUSTOM_ID: option-i-running-emacs-remotely.
    :END:

This was the option I initially started with. Since most of the people
who worked around me used =vim=, remotely, this option came naturally to
me. Since, the remote machine was a Linux system, I
[[https://www.emacswiki.org/emacs/BuildingEmacs][built Emacs]] on the
server and started using it.

Since most of my keyboard shortcuts, in Emacs, are some fancy
combinations of Ctrl, Meta and character keys, the terminal software I
used, ate most of such shortcuts. I tried resetting the terminal
keybindings and changed some complex keybindings but in the end, I had
to give up on that.

Changing my keybindings to make them a little saner for my terminal
emulator, did not seem like an option. Since, rewiring my brain to
create new muscle memory built over 2 years was my last option.

*** Option II: Using Tramp
    :PROPERTIES:
    :CUSTOM_ID: option-ii-using-tramp
    :END:

Emacs has an inbuilt option to connect to remote hosts (via several
protocols) called [[https://www.gnu.org/software/tramp/][Tramp]].
Initially it felt (a lot) easier than the ‘running emacs remotely'
option, but slowly the problems with tramp started to appear.

Tramp was a bit sluggish when opening and saving files. There were some
optimizations that could be done with tramp settings


 #+BEGIN_SRC
 (setq tramp-auto-save-directory "~/tmp/tramp/")
 (setq tramp-chunksize 2000)
 #+END_SRC


and some ssh settings.


 #+BEGIN_EXAMPLE
 Host *
 ControlMaster auto
 ControlPath ~/tmp/.ssh-control-%r-%h-%p

 #+END_EXAMPLE

Even though, these did improve the performance by a large factor, it's
performance on large files and slow network connections, was still a
little below usable.

Apart from this, I had problems running a few Emacs packages such as
[[http://www.flycheck.org/][flycheck]].

*** Option III: Mounting Remote file system locally
    :PROPERTIES:
    :CUSTOM_ID: option-iii-mounting-remote-file-system-locally
    :END:

One of the options I found was mounting a remote file system locally via
[[https://github.com/libfuse/sshfs][sshfs]]. It did have a few problems
with connection stability, but it worked fine overall.

I solved a few problems with some optimizations via command-line
parameters. The final command looked somewhat like this.



 #+BEGIN_EXAMPLE
 sshfs remotehost:/remote/directory/ ~/local/directory -oauto_cache,reconnect,Ciphers=arcfour,Compression=no

 #+END_EXAMPLE

This increased the overall speed and removed sluggishness while editing.

The problem with sshfs is it's speed. Any operation requiring a disk
scan was unbearably slow. So I couldn't run commands like =locate=,
=grep=, and [[https://magit.vc/][=magit=]] via Emacs.

[[https://github.com/bbatsov/projectile][Projectile]] was usable after
=(setq projectile-enable-caching t)= though.

I found a [[https://github.com/ericpruitt/sshfsexec][small utility]]
which addressed this problem. It works by executing all commands which
ran inside a directory mounted on sshfs on the remote host directly. So,
heavy disk operations become very fast as the remote server is doing all
the heavy lifting.

To run any command such as =git= directly on remote all I had to do was



 #+BEGIN_EXAMPLE
 wget https://github.com/ericpruitt/sshfsexec/archive/master.zip
 unzip master.zip
 mv sshfsexec-master sshfsexec
 cd sshfsexec
 mkdir -p ~/bin/sshfsexec
 cp sshfsexec.py ~/bin/sshfsexec
 chmod +x ~/bin/sshfsexec/sshfsexec.py
 export PATH="$HOME/bin/sshfsexec:$PATH"
 cd ~/bin/sshfsexec
 ln -s sshfsexec.py git
 hash -r

 #+END_EXAMPLE

You can check this by running =git --version= from inside and outside
the sshfs mount.

The combination of =sshfs= and =sshfsexec= solved almost all the
problems I faced with earlier setups. It was almost always faster than
tramp when opening and saving of files, and almost as fast as tramp when
doing disk operations such as opening Magit.

The only problem here was the availability of code when offline. And
even though this method was fast, it was not as fast as a project opened
locally. These problems bring us to the fourth option.

*** Option IV: Keeping local copy in sync
    :PROPERTIES:
    :CUSTOM_ID: option-iv-keeping-local-copy-in-sync
    :END:

This is the approach that some of the IDE's take. The code is mirrored
locally and the remote code is kept in sync with the local copy.

There are two parts to this. Firstly, there should be a syncing utility
which does the job of transferring the changes of the file to the remote
copy. The second part of it is the file change notifier which will alert
the syncing utility to start syncing.

Initially, I started with running =rsync= in the =after-save-hook= hook
of emacs. It worked kind of fine, but the problem was with the changes
made outside the scope of Emacs, such as changing of a git branch. It
also restricted me from making any changes on the remote code directly
since there was no mechanism to automatically download the remote copy
changes to the local copy.

On looking a bit further, I came across
[[https://www.cis.upenn.edu/~bcpierce/unison/][Unison]]. It supported
two way syncing along with file watch facility. It is required that same
version Unison is installed on both local and remote machines. Following
are the steps that will setup Unison.



 #+BEGIN_EXAMPLE
 sudo dnf install ocaml ocaml-camlp4-devel
 sudo dnf install ftp://195.220.108.108/linux/fedora-secondary/releases/24/Everything/ppc64le/os/Packages/p/python-inotify-0.9.6-4.fc24.noarch.rpm
 wget https://github.com/bcpierce00/unison/archive/2.48.4.tar.gz
 tar -zxvf 2.48.4.tar.gz
 cd unison-2.48.4
 make NATIVE=true UISTYLE=text
 sudo cp src/unison-fsmonitor /usr/local/bin
 sudo cp src/unison /usr/local/bin
 hash -r

 #+END_EXAMPLE

Repeat these same steps on the server. It is preferable to remove =.git=
folder from syncing. This can be done by creating/editing a
=~/.unison/default.prf= and adding



 #+BEGIN_EXAMPLE
 # Unison preferences file
 ignore = Path {.git}

 #+END_EXAMPLE

You should also remove other build/libraries directories that you won't
be editing. This will decrease the amount of files it has (and memory it
takes in the process) to look for changes.

You can now start the sync by



 #+BEGIN_EXAMPLE
 unison default ~/local/copy ssh://server//remote/copy/path/ -repeat watch -times  -logfile /tmp/unison.log

 #+END_EXAMPLE

This will keep on looking for changes in the local copy and sync the
remote every time there's one.

In the case when a sync is required from the remote to local



 #+BEGIN_EXAMPLE
 unison -batch -times ~/local/copy ssh://server//remote/copy/path/ -logfile /tmp/unison.log

 #+END_EXAMPLE

can be used.

In case of errors such as =Errno=No space left on device (ENOSPC)=, the
inotify memory can be increased by setting
=sudo sysctl fs.inotify.max_user_watches=20480=. This memory uses
[[https://en.wikibooks.org/wiki/The_Linux_Kernel/Memory#Process_Memory_Layout][kernel
memory space]] and is not swappable. Therefore, this shouldn't be
increased too much if you don't have sufficient RAM.

I initially used =sshfs= method for a long time along with =tramp= for
most of my work, but recently have switched to maintaining a local copy
of the codebase.

*** Concluding
    :PROPERTIES:
    :CUSTOM_ID: concluding
    :END:

The choice of the method completely depends on what the purpose of
editing is.

For a quick change in a server I always prefer =tramp=. In the case when
I'm doing some sysadmin work, I prefer installing Emacs on the server
and using =emacsclient= to open and edit files quickly. When working on
code, unless it's not fairly large repository, I prefer =sshfs=. Since
the current scenario requires me to work on a large codebase where sshfs
(kind of) breaks I keep everything copied locally and in sync with the
server.

Posted by Umar Ahmad Apr 11th, 2017   [[/blog/categories/emacs/][Emacs]]

* -Blog Post -- How I Use Emacs

Been meaning to write a post about my current Emacs setup for a while to
explain how I work with Emacs on both Mac and Linux. I am going to call
this my /Emacs Workflow/. I have been using this setup for over a year
now with very few tweaks and it serves me well. I am currently using
Emacs 24, but this setup worked fine for earlier versions.

First, let me explain how I work and what I was looking for out of an
Emacs Workflow. I spend most of my time on the command line. That is
either a terminal or eshell running in Emacs, with really no rhyme or
reason for which. Although longer running things like tailing logs and
stuff over ssh tends to crash Emacs so I typically do not do those
things in eshell. Having used vim for a long time, I got used to quickly
opening a file, making an edit, and then closing it. But I do find it
helpful to have all the currently open files in Emacs available in
buffers. Emacs daemon seemed to fit both of these, but I didn't like
starting it up in my init.el or on login.

Avdi Grimm wrote an article at
[[http://devblog.avdi.org/2011/10/27/running-emacs-as-a-server-emacs-reboot-15/]]
about how he launches Emacs and that got me started. I hadn't used
emacsclient very much before this. The =-a ""= trick was exactly what I
wanted to start the daemon. Avdi uses this script to launch emacsclient
and create a new frame. By default, the terminal waits for you to close
Emacs, but you can pass in -n to the ec script and return control back
to the terminal immediately.

*** My ‘Emacs Workflow'
    :PROPERTIES:
    :CUSTOM_ID: my-emacs-workflow
    :END:

My workflow is a little different. When a file is opened in the Windowed
or GUI version of Emacs, I want to work on it and leave it open. Often
times I am heading back to the terminal to run a command against the
newly edited file, like =rake test= or =mvn package=. That mean the
terminal launching emacsclient shouldn't wait. When there is a GUI
version of emacs already running, I want to use that instead of opening
a new frame. When a GUI Emacs is open but minimized, I want to maximize
it and then open the file there.

For quick edits, I want to open the file quickly in Emacs in the current
terminal, make my edit, and then close it. Therefore, the terminal needs
to wait for me to finish.

**** Sidebar
     :PROPERTIES:
     :CUSTOM_ID: sidebar
     :END:

#+BEGIN_QUOTE
  This method for quick edits is how I did all my git commits before I
  took the time to learn magit. If you haven't used magit, I highly
  recommend you take the time to learn it. See
  [[http://magit.github.io/magit/magit.html]]. This is why I
  =export editor=et= in my ~/.bashrc.
#+END_QUOTE

*** Tools
    :PROPERTIES:
    :CUSTOM_ID: tools
    :END:

So what I ended up with is 2 scripts, which I call /ec/ and /et/,
following Avdi's lead. The former opens emacsclient in the GUI and
returns control immediately to the shell. The latter opens emacs in the
current terminal and waits. Because both scripts are backed by the same
daemon, all open files are available as buffers in both cases. Both
script will starts the daemon if it is not open. The =ec= script has
some extra code to switch focus as described in my workflow. Here are
the scripts, which what I hope are useful comments.

**** ec
     :PROPERTIES:
     :CUSTOM_ID: ec
     :END:


 #+BEGIN_EXAMPLE
 #!/bin/bash

 # This script starts emacs daemon if it is not running, opens whatever file
 # you pass in and changes the focus to emacs.  Without any arguments, it just
 # opens the current buffer or *scratch* if nothing else is open.  The following
 # example will open ~/.bashrc

 # ec ~/.bashrc

 # You can also pass it multiple files, it will open them all.  Unbury-buffer
 # will cycle through those files in order

 # The compliment to the script is et, which opens emacs in the terminal
 # attached to a daemon

 # If you want to execute elisp, pass in -e whatever.
 # You may also want to stop the output from returning to the terminal, like
 # ec -e "(message \"Hello\")" > /dev/null

 # emacsclient options for reference
 # -a "" starts emacs daemon and reattaches
 # -c creates a new frame
 # -n returns control back to the terminal
 # -e eval the script

 # Number of current visible frames,
 # Emacs daemon always has a visible frame called F1
 visible_frames() {
 emacsclient -a "" -e '(length (visible-frame-list))'
 }

 change_focus() {
 emacsclient -n -e "(select-frame-set-input-focus (selected-frame))" > /dev/null
 }

 # try switching to the frame incase it is just minimized
 # will start a server if not running
 test "$(visible_frames)" -eq "1" && change_focus

 if [ "$(visible_frames)" -lt  "2" ]; then # need to create a frame
 # -c $@ with no args just opens the scratch buffer
 emacsclient -n -c "$@" && change_focus
 else # there is already a visible frame besides the daemon, so
 change_focus
 # -n $@ errors if there are no args
 test  "$#" -ne "0" && emacsclient -n "$@"
 fi
 #+END_EXAMPLE

**** et
     :PROPERTIES:
     :CUSTOM_ID: et
     :END:

 #+BEGIN_EXAMPLE
 #!/bin/bash

 # Makes sure emacs daemon is running and opens the file in Emacs in
 # the terminal.

 # If you want to execute elisp, use -e whatever, like so

 # et -e "(message \"Word up\")"

 # You may want to redirect that to /dev/null if you don't want the
 # return to printed on the terminal.  Also, just echoing a message
 # may not be visible if Emacs then gives you a message about what
 # to do when do with the frame

 # The compliment to this script is ec

 # Emacsclient option reference
 # -a "" starts emacs daemon and reattaches
 # -t starts in terminal, since I won't be using the gui
 # can also pass in -n if you want to have the shell return right away

 exec emacsclient -a "" -t "$@"
 #+END_EXAMPLE                                                                     |

*** Github repo
    :PROPERTIES:
    :CUSTOM_ID: github-repo
    :END:

These files can be found in dotfiles repo at
[[https://github.com/mjwall/dotfiles]]. There are also instructions on
how I install Emacs on a
[[https://github.com/mjwall/dotfiles#on-macosx][Mac]] and
[[https://github.com/mjwall/dotfiles#on-linux][Linux]]. Also in this
repo is my ~/.emac.d configuration. I keep everything together to make
it as easy as possible to get setup on a new machine and keep multiple
machines in sync.

**** Warning
     :PROPERTIES:
     :CUSTOM_ID: warning
     :END:

#+BEGIN_QUOTE
  If you are on a Mac, it is important to get the newer version of Emacs
  and emacslient on the path correctly. What has worked for me is
  referenced in the mac
  [[https://gist.github.com/mjwall/3fe935a8becb60dd3c4c][gist]]. Likely
  there are other/better ways.
#+END_QUOTE

*** Bonus, executing elisp
    :PROPERTIES:
    :CUSTOM_ID: bonus-executing-elisp
    :END:

Another way I use these scripts is by passing in -e to execute arbitrary
elisp code. For example, I have an alias setup in my bashrc to launch
magit. Because it is using the same script, it takes advantage of
launching the daemon if necessary and changing focus. Here is what it
looks like:


 #+BEGIN_EXAMPLE
 alias magit='ec -e "(magit-status \"$(pwd)\")"'
 #+END_EXAMPLE

So in the terminal, I run =magit= and it launches Emacs and runs
magit-status on the current directory. This was inspired by a similiar
tweet somewhere, but takes advantage of the rest of the =ec= script.

*** Stopping the Daemon
    :PROPERTIES:
    :CUSTOM_ID: stopping-the-daemon
    :END:

The last piece of this was a shell script to stop the daemon, which is
used for example when I need to reload Emacs configs. Sometimes shutdown
on my Mac hangs while waiting for Emacs to close, so I tend to call this
=es= script beforehand. The script looks like this

**** es
     :PROPERTIES:
     :CUSTOM_ID: es
     :END:


 #+BEGIN_EXAMPLE
 #!/bin/bash

 # simple script to shutdown the running Emacs daemon

 # emacsclient options for reference
 # -a Alternate editor, runs bin/false in this case
 # -e eval the script

 # If the server-process is bound and the server is in a good state, then kill
 # the server

 server_ok() {
 emacsclient -a "false" -e "(boundp 'server-process)"
 }

 if [ "t" == "$(server_ok)" ]; then
 echo "Shutting down Emacs server"
 # wasn't removing emacs from ALT-TAB on mac
 # emacsclient -e "(server-force-delete)"
 emacsclient -e '(kill-emacs)'
 else
 echo "Emacs server not running"
 fi
 #+END_EXAMPLE

Likely there is a good way to fix this hanging, but it doesn't bother me
so I haven't dug deeper.

*** Wrap up
    :PROPERTIES:
    :CUSTOM_ID: wrap-up
    :END:

If you are still reading this, you may be thinking /“This all makes me
want to execute arbitrary elisp in a shell script for other things”/. If
so, and you looked at
[[https://github.com/mjwall/dotfiles/blob/master/bin/ed.el]], you would
see the following example of how to do that


 #+BEGIN_EXAMPLE
 #!/usr/bin/env emacs --script
 (print "Hi mike")
 (require 'server)
 (print (server-running-p))
 #+END_EXAMPLE

Imagine the possibilities. Go through a git repo and change all tabs to
spaces. I haven't really though of anything useful to do with this, but
thought it was interesting.

If you are not still reading this, you probably stopped because you
thought all this was overkill. Maybe you are right.

* Some links
[[https://protesilaos.com/dotemacs/][protesilaos DOTMACS]]
[[http://xenodium.com/][Álvaro Ramírez website]]
[[https://thomashartmann.dev/][tech blog by Thomas Hartmann]]

* General nested menus
I was after something similar to Spacemacs' nested menus when I started working on my own config as well.

To start I created a global-definer with general's general-create-definer macro to set up the global SPC prefix:

#+begin_src emacs-lisp
(global-unset-key (kbd "C-SPC"))
(general-create-definer global-definer
  :keymaps 'override
  :states '(insert emacs normal hybrid motion visual operator)
  :prefix "SPC"
  :non-normal-prefix "C-SPC")

(global-definer
  "!"   'shell-command
  ":"   'eval-expression)
#+end_src

You'll notice I have very little in the way of keybindings declared directly within that definer. I create global menu entries with a macro that creates a keymap with the appropriate settings (wk-full-keys was the missing ingredient for getting which-key to show proper hints for nested menus.
When it was non-nil which-key suggested "lambda" as the binding's description regardless of the command's name).

#+begin_src emacs-lisp
(defmacro general-global-menu-definer (def infix-key &rest body)
  "Create a definer named general-global-DEF wrapping global-definer.
The prefix map is named 'my-DEF-map'."
  `(progn
     (general-create-definer ,(intern (concat "general-global-" def))
       :wrapping global-definer
       :prefix-map (quote ,(intern (concat "my-" def "-map")))
       :infix ,infix-key
       :wk-full-keys nil
       "" '(:ignore t :which-key ,def))
     (,(intern (concat "general-global-" def))
      ,@body)))
#+end_src

Then I define the global menus within general's use-package declaration. If the keybinding is package specific, I use the :general keyword within that package's use-package declaration to add key bindings. If it is not, the macro allows one to define them inline:

;;within general's use-package declaration

;;Just define top level here.
;;Packages will extend these via the general keyword in their own declarations.
#+begin_src emacs-lisp
(general-global-menu-definer
 "application" "a")
#+end_src

;;An example of key bindings that don't belong in other package declarations
#+begin_src emacs-lisp
(general-global-menu-definer
 "buffer" "b"
 "d"  'kill-current-buffer
 "p"  'previous-buffer
 "M" '((lambda () (interactive) (switch-to-buffer "*Messages*"))
       :which-key "messages-buffer")
 "n"  'next-buffer
 "s" '((lambda () (interactive) (switch-to-buffer "*scratch*"))
       :which-key "scratch-buffer")
 "TAB" '((lambda () (interactive) (switch-to-buffer nil))
         :which-key "other-buffer"))
#+end_src

;;Elfeed's use-package declaration extends the keymap created by the macro earlier.
#+begin_src emacs-lisp
(use-package elfeed
  :commands (elfeed)
  :general
  (general-global-application
    "e"    'elfeed))
;;elfeed command is now bound to SPC-a-e
#+end_src

This is the cleanest solution I could manage at the time and it works fine for me, but I admit it's the first macro I've ever written. One shortcoming is that I don't think it works if you want to wrap a definer that's already been wrapped. In those cases I just specify the full keybinding with the
nested map's prefix key. I'm not sure if this is a limitation of general's 'wrapping' keyword or not.

#+BEGIN_SRC emacs-lisp
;;within Org's use-package declaration
  (general-global-application
    "o"    '(:ignore t :which-key "org")
    "oc"   'org-capture
    "oi"   'org-insert-link
    "oj"   '(:ignore t :which-key "journal")
    ;;just manually specify the prefix key for deeper menus
    "ok"   '(:ignore t :which-key "clock")
    "okg"  'org-clock-goto
    "oki"  'org-clock-in-last
    "okj"  'org-clock-jump-to-current-clock
    "oko"  'org-clock-out
    "okr"  'org-resolve-clocks
    "ol"   'org-store-link
    "om"   'org-tags-view
    "os"   'org-search-view
    "ot"   'org-todo-list)
#+END_SRC

If anyone can suggest any improvements or cleaner solutions, I'd love to hear them. Best of luck.

* Automatic gtags integration for Emacs using Git
  :PROPERTIES:
  :CUSTOM_ID: automatic-gtags-integration-for-emacs-using-git
  :END:


It's fairly common to see automatic ctags hooks setup for Vim, but until
recently I haven't been able to get it working in Emacs. Here's how to
do it.

*** [[#git][🔗]]Git
    :PROPERTIES:
    :CUSTOM_ID: git
    :END:

First, create a directory to contain the git hooks to be added in all
new repos.

#+BEGIN_EXAMPLE
  git config --global init.templatedir '~/.git_template'
  mkdir -p ~/.git_template/hooks
#+END_EXAMPLE

Next, add the main script. Place this in =~/.git_template/hooks/gtags=
and mark as executable:

#+BEGIN_EXAMPLE
  #!/bin/sh
  set -o errexit -o nounset

  PATH="/usr/local/bin:$PATH"

  main() (
      root_dir="$(git rev-parse --show-toplevel)"
      git_dir="$(git rev-parse --git-dir)"

      cd "$root_dir"
      trap 'rm -f GPATH GRTAGS GTAGS gtags.files' EXIT
      git grep --cached --files-with-matches "" > gtags.files
      gtags --gtagslabel=pygments
      rm gtags.files
      mv GPATH GRTAGS GTAGS "$git_dir/"

      echo "gtags index created at $git_dir/GTAGS"
  )

  main
#+END_EXAMPLE

Note that the generated tags file is in placed in the =.git= directory,
to avoid cluttering up the directory tree and having to add another
entry in =.gitignore=. This is the key feature for me --- it makes it
feel truly automatic and seamless.

Next, add hooks that wrap this script. The first three are
=post-commit=, =post-merge=, and =post-checkout= and should contain the
following:

#+BEGIN_EXAMPLE
  #!/bin/sh
  .git/hooks/gtags >/dev/null 2>&1 &
#+END_EXAMPLE

Lastly, add one for =post-rewrite=:

#+BEGIN_EXAMPLE
  #!/bin/sh
  case "$1" in
      rebase) exec .git/hooks/post-merge ;;
  esac
#+END_EXAMPLE

Once finished, use =git init= and =git gtags= in existing repositories
to copy the hooks in and generate tags. New repositories will do this
automatically.

*** [[#emacs][🔗]]Emacs
    :PROPERTIES:
    :CUSTOM_ID: emacs
    :END:

To get this working in Emacs depends on which gtags package you have
installed. Unfortunately, =global= does not have an option to directly
change where the tags file is read from, and neither do any of the gtags
packages I've seen. However, it is possible to set two environment
variables to attain this functionality instead, =GTAGSROOT= and
=GTAGSDBPATH=.

#+BEGIN_EXAMPLE
  (defun gtags-env-patch (orig &rest args)
    (if-let* ((project-root (file-truename (locate-dominating-file "." ".git")))
              (git-dir (expand-file-name ".git" project-root))
              (process-environment (append
                                    (list (format "GTAGSROOT=%s" project-root)
                                          (format "GTAGSDBPATH=%s" git-dir))
                                    process-environment)))
        (apply orig args)
      (apply orig args)))
#+END_EXAMPLE

Then, you can wrap the appropriate functions using
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html][=advice=]].

*** [[#counsel-ivy][🔗]]Counsel (Ivy)
    :PROPERTIES:
    :CUSTOM_ID: counsel-ivy
    :END:

For [[https://github.com/syohex/emacs-counsel-gtags][counsel-gtags]]
(i.e., ivy completion):

#+BEGIN_EXAMPLE
  (advice-add #'counsel-gtags-find-reference :around #'gtags-env-patch)
  (advice-add #'counsel-gtags-find-symbol :around #'gtags-env-patch)
  (advice-add #'counsel-gtags-find-definition :around #'gtags-env-patch)
  (advice-add #'counsel-gtags-dwim :around #'gtags-env-patch)
#+END_EXAMPLE

*** [[#helm][🔗]]Helm
    :PROPERTIES:
    :CUSTOM_ID: helm
    :END:

For [[https://github.com/syohex/emacs-helm-gtags][helm-gtags]]:

#+BEGIN_EXAMPLE
  (advice-add #'helm-gtags-find-tag :around #gtags-env-patch)
  (advice-add #'helm-gtags-dwim :around #'gtags-env-patch)
  (advice-add #'helm-gtags-find-tag-other-window #'gtags-env-patch)
#+END_EXAMPLE

That's it. Now any new repositories will be automatically indexed
whenever they are checked out, committed, or rebased, and the tags file
will be found seamlessly without any user input.

If you have a better method or suggested fix, please shoot me an email
or comment on the
[[https://www.reddit.com/r/emacs/comments/f2yxts/automatic_gtags_integration_for_emacs_using_git][Reddit
post]].

* ORG-MODE FEATURES YOU MAY NOT KNOW

Org-mode features You May Not Know

Publié le Mon 27 Jan 2020 par Bastien

When I meet fellow orgers, I occasionally use some of the features below and
quite often, my interlocutor does not know some of them.

Do you know them all?

If you think of a secret Org weapon that is not listed here, please send me an
email, I will consider addign it to the list.

(The features listed below are all available with Org 9.3 and later. Check your
version with M-x org-version

~C-c C-M-l~ to insert all stored links with

Let's say you have harvested a dozen of links to various emacs buffers (emails,
files, etc.)

~C-c C-M-l~ will insert all the links as a list.

The related command is org-insert-all-links.

~C-u C-c C-c~ on a list to make it a checklist

It will turn the list into a checkbox list.

Use agenda* as a custom view to match appointments

Quoting the Org manual:

The agenda* view is the same as agenda except that it only considers
appointments, i.e., scheduled and deadline items that have a time specification
[h]h:mm in their time-stamps.

Very useful when defining agenda views dedicated to appointments.

Contextual capture templates


#+BEGIN_SRC
(setq org-capture-templates-contexts
      '(("r" ((in-mode . "gnus-summary-mode")
	      (in-mode . "gnus-article-mode")
	      (in-mode . "message-mode")))))
#+END_SRC

Here the capture template associated with the r key will only be displayed in
gnus-summary-mode, gnus-article-mode and message-mode.

~C-h v org-agenda-max-entries RET~

Will tell you more about this variable.

For example, this will present only the first three entries of today's tasks:

~C-x C-w~ agenda.org RET in an agenda view


(setq org-agenda-custom-commands
      '(("%" "Appointments" agenda* "Today's appointments"
	 ((org-agenda-span 1)
          (org-agenda-max-entries 3)))))

It will store the displayed list of tasks in a new agenda.org file.

Hit = in agenda views to filter by a regex

Very useful to (export and) share your current list of tasks with someone.

Hitting = in the agenda buffer will limit to headlines matching a regular
expression.

You can remove all filters by hitting |.

. in a the calendar to jump to today

Use - or + to set relative date and hours when planning

After C-c C-s on a headline scheduled in the past or the future, use ~.~ to jump
to today's date.

After you hit C-c C-s on a headline to schedule it, enter e.g. +3d to plan in
three days, or 10:00+1 to plan an meeting from 10am to 11am.

Use S-<up/down/left/right> to move a table cell

It will move the current cell up/down/left/right.

Summing durations in tables

Org tables are able to sum durations:


| 00:00:30 | 2:30 |
| 00:00:45 | 3:30 |
|----------+------|
| 00:01:15 | 6.00 |
#+TBLFM: @3$1=vsum(@1..@2);T::@3$2=vsum(@1..@-1);t

Hit s to (un)narrow to subtree

When org-use-speed-commands is set to t, hitting s at the beginning of a
headline will narrow to the current subtree. Hitting s again will unnarrow the
buffer.

Very useful when you need to hide the rest of your personal notes from your
colleagues.

The related command is org-narrow-to-subtree.

Hit < to (de)activate restriction lock on current subtree

When org-use-speed-commands is set to t, hitting < at the beginning of a
headline will activate the restriction lock on the current subtree. Hitting <
again will deactivate it.

Very useful when you temporarily need to call agenda views while only
considering tasks in the current subtree or when you need to undo things in the
current subtree alone.

The related command is org-agenda-set-restriction-lock.

C-c C-^ to move at the root of the element

C-c C-^ (or C-c C-u) while move the cursor up one element.

C-c - and C-c * to toggle headlines and items

C-c - on a headline will convert it into a list item.

C-c * on a list item will convert it into a headline.

You can also try on multiple headlines and list items.

C-c C-x - to start a list with a timer


- 0:00:00 :: Now I can start taking some notes.
- 0:00:02 :: If I hit ~M-RET~, a new list item is created.
- 0:00:06 :: And so on.

C-c C-x - will start a timer and create a list item displaying the timer like
the example above.

Schedule multiple headlines in the region

When org-loop-over-headlines-in-active-region is set to t and the region is
active on multiple headline, you can use C-c C-s to schedule all the headlines
one after another.

M-h for mark-paragraph and org-mark-element

M-h will mark (and highlight) the paragraph at point.

In org-mode, M-h will mark (and highlight) the element at point.

Hitting M-h several times successively will mark the next elements too.

M-<up/down> and S-M-<up/down> to move elements and lines

Just hit M-<up/down> in an Org buffer. It moves elements.

Now hit ~S-M-~: it moves the current line up/down.

S-<left/right> in column mode to cycle through property values

If a property can have multiple predefined values and the column view is active,
you can use S-<left/right> in column mode to cycle through possible property
values.

Using group tags to boost filtering

I use something like this in my configuration:


(setq org-tag-alist
      '((:startgroup)
	("Handson" . ?o) ;; The grouping tag
	(:grouptags)
	("Write" . ?w) ("Code" . ?c) ("Mail" . ?@)
	(:endgroup)
	(:startgroup)
	("Handsoff" . ?f) ;; The grouping tag
	(:grouptags)
	("Read" . ?r) ("View" . ?v) ("Listen" . ?l)
	(:endgroup)
	;; Off groups
	("Print" . ?P) ("Buy" . ?B) ("Patch" . ?p) ("Bug" . ?b)))

Then M-x org-agenda RET m +Handsoff will list all headlines with a Read, View or
Listen tag.

Adjusting timestamps in CLOCK: lines

*** S-up/down on a timestamp in a CLOCK: line will adjust the timestamp.
*** C-S-up/down on a timestamp in a CLOCK: line will adjust both timestamp, the
  time you clocked in and the time you clocked out: the clock duration will not
  change.
*** M-S-up/down on a timestamp in a CLOCK: line will also adjust previous clocks
  timestamps, if any.

C-u C-u C-c c to jumb back to the last stored capture entry

C-u C-u C-c c will jump to the last captured note. The one you may actually want
to update if you forgot something.

M-x org-num-mode RET to prefix headlines with numbers

M-x org-num-mode RET will prefix headlines with a number.

* Speeding up your Emacs start up time
**** [[https://medium.com/@holzman.simon/emacs-on-macos-catalina-10-15-in-2019-79ff713c1ccc][Speedup emacs]]

#+BEGIN_SRC bash

#!/bin/bash
# Note: X windows are referred as frames, since for emacs a window is a split of a frame. This script is called em.
# The help part.
# If I type in help, or -h... I get something at least.
if [ “$1” == “help” ] || [ “$1” == “ — help” ] || [ “$1” == “-h” ]; then
 echo “A dumb script to deal with Emacs Client Frame”
 echo “Open a file in the existing frame or create a frame if none”
 echo “If multiple frames are open, the file will be opened in the last focused frame”
 echo “”
 echo “usage: em <name of file> [w]”
 echo “ — \”w\” forces the creation of a frame even if there is already one”
exit
fi
# Now the meat part.
# We use the command emacsclient. Get the state of the emacsclient, ‘nil’ if no frame is opened and ‘t’ if a is frame is opened
state=”$(emacsclient -qn -e “(if (> (length (frame-list)) 1) ‘t)”)”
# If the server is off OR if there is no frame already opened OR if we explicitly ask for a frame using the suffix “w”
if [ “$state” == “” ] || [ “$state” == “nil” ] || [ “$2” == “w” ] ; then
 # Create a frame and open the file within it
 emacsclient -a ‘’ -cqn $1
else
 # Open the file in the existing frame
 emacsclient -qn $1
fi

#+END_SRC

* To Auto export org file to html

  Place this in the first line of the org file. Now emacs will start a background task to export the current file and you are able to work in the meantime.
  Because html export ist much faster than latex processing in my current setup I export to html and have emacs on the left half of the screen and on the other my browser.
  Every time I save my document the browser preview updates automatically
  #+BEGIN_SRC emacs-lisp
  # -*- after-save-hook: org-html-export-to-html; org-export-in-background: t; -*-

  #+END_SRC

* Convert .org to .docx with citations


Last year around this time, I was working on a paper and it was requested that I
submit it to the professor in .docx format for easier commenting. I hadn’t
really built this into my workflow at the time (always going from .org or .tex
straight to .pdf), and so I decided to figure out how to do it. Now exporting to
.docx isn’t really too much of a problem with Org-mode, since you can export to
an LibreOffice .odt format and convert it from there.

The trouble that I was having with the Org .odt exporter was that it wasn’t
dealing with my biblatex citations. They would just show up as cite commands or
something like that. The solution that I’ve found is to use pandoc and that
works pretty well. But setting the options for this function was tedious, and so
I created a function in my bash profile so that I could do this easily with a
org2docx command. (Note: You can use this for other types of files (such as
markdown), too. I just care about org files here.)

Here are the steps that I used:

,* First, you will need to install [[http://johnmacfarlane.net/pandoc/][pandoc]]. This is easy with [[http://brew.sh/][homebrew]]: brew
  install pandoc.
,* You should also install [[https://github.com/jgm/pandoc-citeproc][pandoc-citeproc]]: brew install pandoc-citeproc
,* You should [[https://github.com/citation-style-language/styles][download the .csl files from Github]] and put them in an
  easy-to-access directory.
,* I think it is a good idea to create a reference.docx template for creating a
  custom style for your new .docx files. There is [[https://github.com/jgm/pandoc-templates/issues/20][a short post on that here]]. You
  then need to play with the styles in the file to your liking and put it in an
  easy to reference place.
,* After that, you should open ~/.bash_profile in your favorite text editor and
  add the following function with the appropriate modifications (see below for a
  discussion of the options) for your setup:

org2docx() {
		pandoc --bibliography=/path/to/your/bibliographyfile.bib --csl=/path/to/your/csl/chicago-fullnote-bibliography.csl --reference-docx=/path/to/your/reference.docx -i $1 -o $1-pandoc.docx
	}

,* You will need to run source ~/.bash_profile to load the changes.

You can now convert documents like this: org2docx MyPaper.org fairly easily
without having to bother with the options every time.

Here’s what the various options do:

,* --bibliography=/path/to/your/bibliographyfile.bib. You specify the path to
  your bibliography file here. Since I maintain a single .bib file for all my
  references, I don’t need to change this across different papers.
,* --csl=/path/to/your/csl/chicago-fullnote-bibliography.csl. You specify the
  path to your .csl file here. You can pick any of them in the csl files from
  Github.

  * You may want to pick the chicago-fullnote-bibliography-no-ibid.csl for .docx
    files. Normally when you create a .pdf file with biblatex-chicago, the
    footnotes go from: full citation in the footnote to short citation in the
    footnote to “Ibid” citation. Then, on each new page, it starts with the
    short citation and moves to Ibid. This is so that you don’t have to flip
    back to previous pages to see what the reference is. Not so with the .docx
    conversion. Not allowing “ibid” citations might be a good idea then.

,* --reference-docx=/path/to/your/reference.docx This is optional, but it allows
  you to have a custom .docx style. You can make this closer, for instance, to
  whatever LaTeX style you use.
,* -i $1 -o $1-pandoc.docx. -i $1 just says that it’ll take the first argument as
  your input file. -o $1-pandoc.docx just says that it will output the file with
  the filename but with -pandoc.docx appended.
,* If you want to automatically open the .docx file after converting, you will
  want to include a open $1-pandoc.docx command as well.

[[https://www.clarkdonley.com/tags/org/][org]]

* Elisp tutorial


Emergency Elisp

Are you an Emacs user but don't know Lisp? Welcome to my first Emacs Lisp
primer! This should hopefully help get you over the hurdle so you can have more
control over your Emacs sessions.

There are lots of ways to do things in Lisp, and some are "Lispier" than others.
I'm going to focus on how to do things you probably already know how to do from
C++ or Java.

I'm mostly focusing on the language itself, since that's arguably the hardest
part. There are tons of Emacs-specific APIs that you can learn how to use from
the documentation.

Lisp is good at some things (like code that generates code) and not so good at
others (like arithmetic expressions). I will generally avoid talking about good
vs. bad, and just talk about how to do things. Emacs Lisp is like any other
language – you get used to it eventually.

Most Lisp introductions try to give you the "Tao of Lisp", complete with
incense-burning, chanting, yoga and all that stuff. What I really wanted in the
beginning was a simple cookbook for doing my "normal" stuff in Lisp. So that's
what this is. It's an introduction to how to write C, Java or JavaScript code in
Emacs Lisp, more or less.

Here goes. Let's see how short I can make it. I'll start with the boring (but
hopefully familiar) lexical tokens and operators, then move on to how to
implement various favorite statements, declarations and other programming
constructs.

Quick Start

Lisp is written as nested parenthesized expressions like (+ 2 3). These
expressions are sometimes called forms (in the sense of "shapes".)

There are also "atoms" (leaf nodes, basically) that are not parenthesized:
strings, numbers, symbols (which must be quoted with apostrophe for use as
symbols, like 'foo), vectors, and other miscellany.

There are only single-line comments: semicolon to end of line.

To set a variable named foo to the value "bar":
(setq foo "bar")  ; setq means "set quoted"

To call a function named foo-bar with arguments "flim" and "flam":
(foo-bar "flim" "flam")

To compute the arithmetic expression (0x15 * (8.2 + (7 << 3))) % 2:
(% (* #x15 (+ 8.2 (lsh 7 3))) 2)

In other words, arithmetic uses prefix notation, just like lisp function calls.

There's no static type system; you use runtime predicates to figure out the type
of a data item. In elisp, predicate functions often end with "p". I'll let you
figure out what it stands for.

Important: You can (and should) experiment with Lisp in the *scratch* buffer.
You can evaluate an expression and see its result in any of several ways,
including:

1 Put your cursor after the last close-paren and type C-j (control + j)

2 Put your cursor inside the expression and type M-C-x (alt + control + x)

3 Put your cursor after the last close-paren and type C-x C-e

The first approach spits the result into the *scratch* buffer, and the next two
echo it into the minibuffer. They all also work for atoms – expressions not in
parens such as numbers, strings, characters and symbols.

Lexical Stuff

Lisp has only a handful of lexical tokens (i.e. atomic program elements).

Comments:

Single-line only. They start with a semicolon:
(blah blah blah)   ;  I am a comment

Strings:

Double-quoted only.
"He's said: \"Emacs Rules\" one time too many."

You can embed newlines in strings, like so:
"Oh Argentina!
Your little tin of pink meat
Soars o'er the Pampas"

** Characters:

**** ?x is the syntax for an ASCII character: ? followed by the character.

**** e.g.: ?a is ascii 97 ('a'), ? (that is, question-mark space) is ascii 32 ('
  ').

**** Some need to be escaped, such as ?\(, ?\) and ?\\

**** Emacs 22+ has unicode support. Out of scope for this primer.

Characters are just int values internally, so you can use arithmetic operations
on them (for instance, to iterate through ?a to ?z).

** Numbers:

**** Integers are 29 bits of precision (not the usual 32). -32, 0, 157, etc.

**** Binary: start with #b, e.g. #b10010110

**** Octal: #o[0-7]+, e.g. #o377

**** Hexadecimal: start with #x, e.g. #xabcd, #xDEADBEE

**** Floating-point: the usual. -10.005, 0.0, 3.14159265 (64 bits of precision.)

**** Scientific: the usual. 6.02e23, 5e-10

The variables most-positive-fixnum and most-negative-fixnum are the largest and
smallest integers representable in Emacs Lisp without bignum support. Emacs 22+
comes with a fancy bignum/math library called calc, if you need it. Arithmetic
operations overflow and underflow the way you'd expect (in, say, C or Java.)

** Booleans
   The symbol t (just a letter 't' by itself) is true.

   The symbol nil is false (and also means null).

In Emacs Lisp, nil is the only false value; everything else evalutes to true in
a boolean context, including empty strings, zero, the symbol 'false, and empty
vectors. An empty list, '(), is the same thing as nil.

** Arrays

   Elisp has fixed-sized arrays called "vectors". You can use square-brackets to
   create a pre-initialized literal vector, for instance:
   [-2 0 2 4 6 8 10]
   ["No" "Sir" "I" "am" "a" "real" "horse"]
   ["hi" 22 120 89.6 2748 [3 "a"]]

   Note that you do not (and cannot) use commas to separate the elements; use
   whitespace.

   Vectors can have mixed-type elements, and can be nested. You usually use the
   function make-vector to create them, since literal vectors are singletons, which
   can be surprising.

** Lists

   Lisp makes heavy use of linked lists, so there's lexical syntax for them.
   Anything in parentheses is a list, but unless you quote it, it will be evaluated
   as a function call. There are various ways to quote things in Lisp:
   (quote (1 2 3)) ; produces the list (1 2 3) with no list-element evaluation
   '(1 2 3)  ; apostrophe is shorthand for (quote (...))
   ; note that it goes _outside_ the left-paren
   (list 1 (+ 1 1) 3) ; also produces (1 2 3), since it evaluates the elements first
   `(1 ,(+ 1 1) 3)  ; another (1 2 3) via a template system called "backquote"
   There's a lot more that could be said about lists, but other people have already
   said it.

** Pairs

   You can set the head and tail (also known as car and cdr) fields of a lisp
   link-list node struct (also known as a cons cell) directly, using it as a
   2-element untyped struct. The syntax is (head-value . tail-value), and you have
   to quote it (see above).

   A common lookup-table data-structure for very small data sets is an associative
   list (known as an alist). It's just a list of dotted pairs, like so:
   '( (apple . "red")
   (banana . "yellow")
   (orange . "orange") )
   Emacs Lisp has built-in hashtables, bit-vectors, and miscellaneous other data
   structures, but there's no syntax for them; you create them with function calls.

** Operators

   Some operations that are typically operators in other languages are function
   calls in elisp.

** Equality

   Numeric equality: (= 2 (+ 1 1)) Single-equal. Yields t or nil. Works for floats
   too.

   Not-numerically-equal: (/= 2 3) I know, it looks like assign-divide-equal. But
   it's not.

   Value equality: (eq 'foo 2) Like Java ==. Works for ints, symbols, interned
   strings, and object references. Use eql for floating-point numbers (or just =).

   Deep (structural) equality: use equal, as in:
   (equal '(1 2 (3 4)) (list 1 2 (list 3 (* 2 2))))  ; true

   The equal function is like Java's Object.equals(). Works for lists, vectors,
   strings, and just about anything else.

** String

   Strings don't have any operators, but there are lots of string functions. Some
   common ones:
   (concat "foo" "bar" "baz")  ; yields "foobarbaz"

   (string= "foo" "baz")  ; yields nil (false).  Can also use equal.

   (substring "foobar" 0 3) ; yields "foo"

   (upcase "foobar")  ; yields "FOOBAR"

   Do =M-x apropos RET \bstring\b RET= to see a list of functions related to strings.

** Arithmetic

Easiest to show as a table...
| C/Java/JS Operator   | Emacs Lisp                           | Example            | Result                         |
|----------------------+--------------------------------------+--------------------+--------------------------------|
| +                    | +                                    | (+ 1 2 3 4 5)      | 15                             |
| -                    | -                                    | (- 6 2 3)          | 1                              |
| *                    | *                                    | (* 2 -1 4.2)       | -8.4                           |
| /                    | /                                    | (/ 10 3)           | 3 (use floats for float div)   |
| %                    | %                                    | (% 10 2)           | 0                              |
| <<                   | lsh                                  | (lsh 1 5)          | 32                             |
| >>                   | ash (negative amount)                | (ash -32 -4)       | -2                             |
| >>>                  | lsh (negative amount)                | (lsh 32 -4)        | 2                              |
| ++                   | incf (requires 'cl library)          | (incf x 6)         | x+6                            |
| --                   | decf (ditto)                         | (decf x 5)         | x-5                            |
| ? : (ternary)        | (if test-expr then-expr else-expr)   | (if t 3 4)         | 3                              |
| &&                   | and                                  | (and t t t nil)    | nil                            |
|                      |                                      |                    | or                             |
| ! (logical-not)      | not                                  | (not 3)            | nil                            |
| ~ (bit-not)          | lognot                               | (lognot #b1001)    | -10                            |
| ^ (bit-xor)          | logxor                               | (logxor 5 3)       | 6                              |
| & (bit-and)          | logand                               | (logand 1 3)       | 1                              |
|                      | (bit-or)                             | logior             | (logior 1 3)                   |
| <                    | <                                    | (< 5 3)            | nil                            |
| >                    | >                                    | (> 5 3)            | t                              |
| <=                   | <=                                   | (<= 3 3)           | t                              |
| >=                   | >=                                   | (>= 5 3)           | t                              |
| . (field access)     | see setf below                       | n/a                | n/a                            |
| [] (array access)    | aref/aset                            | (aref [2 4 6] 1)   | 4                              |


** Statements

This section has some recipes for simple Java-like statements. It's not
comprehensive – just some recipes to get you going.

*** if/else

**** Case 1: no else clause: (if test-expr expr)

Example:

#+BEGIN_SRC emacs-lisp
(if (>= 3 2)
  (message "hello there"))
#+END_SRC

**** Case 2: else clause: (if test-expr then-expr else-expr)

#+BEGIN_SRC emacs-lisp
(if (today-is-friday)         ; test-expr
    (message "yay, friday")   ; then-expr
  (message "boo, other day")) ; else-expr
#+END_SRC


If you need multiple expressions (statements) in the then-expr, you wrap them
with a call to progn, which is like curly-braces in C or Java:

#+BEGIN_SRC emacs-lisp
(if (zerop 0)
    (progn
      (do-something)
      (do-something-else)
      (etc-etc-etc)))
#+END_SRC

You don't need the progn around the else-expr – everything after the then-expr
is considered to be part of the else-expr. Hence:

#+BEGIN_SRC emacs-lisp
(if (today-is-friday)
    (message "yay, friday")
  (message "not friday!")
  (non-friday-stuff)
  (more-non-friday-stuff))
#+END_SRC

**** Case 3: else-if clause: Just nest 'em. Or use cond (see below).

#+BEGIN_SRC
(if 'sunday
    (message "sunday!")      ; then-expr
  (if 'saturday              ; else-if
      (message "saturday!")  ; next then-expr
    (message ("weekday!")))) ; final else
#+END_SRC

**** Case 4: no else-if, multiple body expressions – use when:

If you don't have an else-clause, then you can use the when macro, which
provides an implicit progn:

#+BEGIN_SRC emacs-lisp
(when (> 5 1)
  (blah)
  (blah-blah)
  (blah blah blah))
#+END_SRC

You can also use unless, which is like when but inverts the sense of the test:
(unless (weekend-p)
  (message "another day at work")
  (get-back-to-work))

*** switch

Elisp has two versions of the classic switch statement: cond and case.

Elisp does not have a table-lookup optimization for switch, so cond and case are
just syntax for nested if-then-else clauses. However, if you have more than one
level of nesting, it looks a lot nicer than if expressions. The syntax is:

#+BEGIN_SRC
(cond
  (test-1
    do-stuff-1)
  (test-2
    do-stuff-2)
  ...
  (t
    do-default-stuff))
#+END_SRC

The do-stuff parts can be any number of statements, and don't need to be wrapped
with a progn block.

Unlike classic switch, cond can handle any test expression (it just checks them
in order), not just numbers. The downside is that it doesn't have any
special-casing for numbers, so you have to compare them to something. Here's one
that does string compares:

#+BEGIN_SRC
(cond
 ((equal value "foo")  ; case #1 – notice it's a function call to `equal' so it's in parens
  (message "got foo")  ; action 1
  (+ 2 2))             ; return value for case 1
 ((equal value "bar")  ; case #2 – also a function call (to `+')
  nil)                 ; return value for case 2
 (t                    ; default case – not a function call, just literal true
  'hello))             ; return symbol 'hello
#+END_SRC

The final t default clause is optional. The first matching clause is executed,
and the result of the entire cond expression is the result of the last
expression in the matching clause.

The 'cl (Common Lisp) package bundled with Emacs provides case, which works if
you're comparing numbers or symbols, so in a sense it works more like standard
switch. Example:

#+BEGIN_SRC
(case 12
  (5 "five")
  (1 "one")
  (12 "twelve")
  (otherwise
   "I only know five, one and twelve."))  ; result:  "twelve"
#+END_SRC

With case you can use either t or otherwise for the default case, but it must
come last.

It's cleaner to use case when you can get away with it, but cond is more
general.

*** while

Elisp has a relatively normal while function: (while test body-forms)

Example, which you can evaluate in your *scratch* buffer:

#+BEGIN_SRC
(setq x 10
      total 0)
(while (plusp x)  ; while x is positive
  (incf total x)  ; add x to total
  (decf x))       ; subtract 1 from x
#+END_SRC

First we set two global variables, x=10 and total=0, then run the loop. Then we
can evaluate the expression total to see that its value is 55 (the sum of the
numbers 1 to 10).

*** break/continue

Lisp has a facility for upward control-flow transfers called catch/throw. It's
very similar to Java or C++ exception handling, albeit possibly somewhat
lighter-weight.

To do a break from inside a loop in elisp, you put a (catch 'break ...) outside
the loop, an a (throw 'break value) wherever you want to break insie the loop,
like so:
#+begin_example

Emacs Lisp                       Java
 (setq x 0 total 0)              var x = total = 0;
 (catch 'break                   while (true) {
   (while t                      total + = x;
     (incf total x)              if (x++ > 10) {
     (if (> (incf x) 10)                break;
         (throw 'break total))))          }
             }
#+end_example

The symbol 'break is arbitrary, but is probably a nice choice for your reaers.
If you have neste loops, you might consider 'break-outer and 'break-inner in
your catch expressions.

You can (throw 'break nil) if you don't care about the "return value" for the
while-loop.

To continue a loop, put a catch expression just inside the loop, at the top. For
instance, to sum the numbers from 1 to 99 that are not evenly divisible by 5
(artificially lame example demonstrating use of continue):

#+begin_example

Emacs Lisp                        Java
 (setq x 0 total 0)             var x = total = 0;
 (while (< x 100)               while (x < 100) {
   (catch 'continue             x++;
     (incf x)                   if (x % 5 == 0) {
     (if (zerop (% x 5))                continue;
         (throw 'continue nil))         }
       (incf total x)))                  total += x;
                                        }
#+end_example

We can combine these examples to show using a break and continue in the same
loop:
#+begin_example

 Emacs Lisp                             JavaScript
 (setq x 0 total 0)                     var x = total = 0;
 (catch 'break                          while (true) {
   (while t                                     x++;
     (catch 'continue                           if (x >= 100) {
       (incf x)                                 break;
       (if (>= x 100)                           }
           (throw 'break nil))                          if (x % 5 == 0) {
       (if (zerop (% x 5))                          continue;
           (throw 'continue nil))                        }
       (incf total x))))                        total += x;
                                                }
#+end_example

All the loops above compute the value 4000 in the variable total. There are
better ways to compute this result, but I needed something simple to illustrate
break and continue.

The catch/throw mechanism can be used across function boundaries, just like
exceptions. It's not intended for true exceptions or error conditions – Emacs
has another mechanism for that, discussed in the try/catch section below. You
should get comfortable using catch/throw for normal jumps and control transfer
in your Elisp code.

*** do/while

Pretty much all iteration in Emacs Lisp is easiest using the loop macro from the
Common Lisp package. Just do this to enable loop:
(require 'cl)  ; get lots of Common Lisp goodies

The loop macro is a powerful minilanguage with lots of features, and it's worth
reading up on. I'll use it in this primer to show you how to do basic looping
constructs from other languages.

You can do a do/while like so:

#+BEGIN_SRC
(loop do
      (setq x (1+ x))
      while
      (< x 10))
#+END_SRC

You can have any number of lisp expressions between the do and while keywords.

for

The C-style for-loop has four components: variable initialization, the loop
body, the test, and the increment. You can do all that and more with the loop
macro. For instance, this arbitrary JavaScript:

#+BEGIN_SRC
// JavaScript
var result = [];
for (var i = 10, j = 0; j <= 10; i--, j += 2) {
  result.push(i+j);
}
#+END_SRC

Could be done with loop like so:

#+BEGIN_SRC
(loop with result = '()         ; one-time initialization
      for i downfrom 10         ; count i down from 10
      for j from 0 by 2         ; count j up from 0 by 2
      while (< j 10)            ; stop when j >= 10
      do
      (push (+ i j) result)     ; fast-accumulate i+j
      finally
      return (nreverse result)) ; reverse and return result
#+END_SRC

It's a bit more verbose, but loop has a lot of options, so you want it to be
reasonably transparent.

Notice that this loop declares the result array and then "returns" it. It could
also operate on a variable declared outside the loop, in which case we wouldn't
need the finally return clause.

The loop macro is astoundingly flexible. Its full specification is way out of
scope for this primer, but if you want to make Emacs Lisp your, uh, friend, then
you should spend some time reading up on loop.

*** for..in

If you're iterating over a collection, Java provides the "smart" for-loop, and
JavaScript has for..in and for each..in. There are various ways to do it in
Lisp, but you really might as well just learn how to do it with the loop macro.
It's a one-stop shop for iteration.

The basic approach is to use loop for var in sequence, and then do something
with the individual results. You can, for instance, collect them (or a function
on them) into a result list like so:

#+BEGIN_SRC
(loop for i in '(1 2 3 4 5 6)
      collect (* i i))           ; yields (1 4 9 16 25 36)
#+END_SRC

The loop macro lets you iterate over list elements, list cells, vectors,
hash-keys, hash-values, buffers, windows, frames, symbols, and just about
anything else you could want to traverse. See the Info pages or your Emacs
manual for details.

functions

You define a function with defun.

Syntax: (defun function-name arg-list [optional docstring] body)

#+BEGIN_SRC
(defun square (x)
  "Return X squared."
  (* x x))
#+END_SRC

For a no-arg function, you use an empty list:

#+BEGIN_SRC
(defun hello ()
  "Print the string `hello' to the minibuffer."
  (message "hello!"))
#+END_SRC

The body can be any number of expressions. The return value of the function is
the result of the last expression executed. You do not declare the return type,
so it's useful to mention it in the documentation string. The doc string is
available from =M-x describe-function= after you evaluate your function.

Emacs Lisp does not have function/method overloading, but it supports optional
and "rest" parameters similar to what Python and Ruby offer. You can use the
full Common Lisp specification for argument lists, including support for keyword
arguments (see the defstruct section below), if you use the defun* macro instead
of defun. The defun* version also lets you (return "foo") without having to set
up your own catch/throw.

If you want your function to be available as a M-x command, put (interactive) as
the first expression in the body after the doc string.

*** local variables

You declare function local variables with the let form. The basic syntax is (let
var-decl var-decl)

#+BEGIN_SRC
(let ((name1 value1)
      (name2 value2)
      name3
      name4
      (name5 value5)
      name6
      ...))
#+END_SRC

Each var-decl is either a single name, or (name initial-value). You can mix
initialized and uninitialized values in any order. Uninitialized variables get
the initial value nil.

You can have multiple let clauses in a function. Code written for performance
often collects all declarations into a single let at the top, since it's a bit
faster that way. Typically you should write your code for clarity first.

*** reference parameters

C++ has reference parameters, which allow you to modify variables from the
caller's stack. Java does not, so you have to work around it occasionally by
passing in a 1-element array, or using an instance variable, or whatever.

Emacs Lisp does not have true reference parameters, but it has dynamic scope,
which means you can modify values on your caller's stack anyway. Consider the
following pair of functions:

#+BEGIN_SRC
(defun foo ()
  (let ((x 6))  ; define a local (i.e., stack) variable x initialized to 6
    (bar)       ; call bar
    x))         ; return x

(defun bar ()
  (setq x 7))   ; finds and modifies x in the caller's stack frame
#+END_SRC

If you invoke (foo) the return value is 7.

Dynamic scoping is generally considered a bad design bordering on evil, but it
can occasionally come in handy. If nothing else, it's good to know it's what
Emacs does.

*** return

A lisp function by default returns the value of the last expression executed in
the function. Sometimes it's possible to structure your function so that every
possible return value is in a "tail position" (meaning the last expression out
before the door closes, so to speak.) For instance:


#+BEGIN_SRC
 Emacs Lisp                                     JavaScript
 (require 'calendar)                            function dayName() {
                                                var date = new Date().getDay();
 (defun day-name ()                                     switch (date) {
   (let ((date (calendar-day-of-week                    case 0:
                (calendar-current-date))))              return "Sunday";
     (if (= date 0)                                     case 6:
         "Sunday"                                       return "Saturday";
       (if (= date 6)                                   default:
           "Saturday"                                   return "weekday";
         "weekday"))))                                  }
                                                      }
#+END_SRC


The return value is just the result of the last expression, so whatever our
nested if produces is automatically returned, and there's no need here for an
explicit return form.

However, sometimes restructuring the function this way is inconvenient, and
you'd prefer to do an "early return".

You can do early returns in Emacs Lisp the same way you do break and continue,
using the catch/throw facility. Usually simple functions can be structured so
you don't need this – it's most often useful for larger, deeply-nested
functions. So for a contrived example, we'll just rewrite the function above to
be closer to the JavaScript version:

#+BEGIN_SRC
(defun day-name ()
  (let ((date (calendar-day-of-week
               (calendar-current-date))))  ; 0-6
    (catch 'return
      (case date
        (0
         (throw 'return "Sunday"))
        (6
         (throw 'return "Saturday"))
        (t
         (throw 'return "weekday"))))))
#+END_SRC

Obviously using catch/throw here is slow and clunky compared to the
alternatives, but sometimes it's exactly what you need to get out of a deeply
nested construct.

*** try/catch

We've already discussed catch/throw, an exception-like facility for normal
control flow transfers.

Emacs has a different facility for real error conditions, called the
"conditions" system. Going through the full system is out of scope for our
primer, but I'll cover how to catch all exceptions and how to ignore (squelch)
them.

Here's an example of a universal try/catch using the condition-case construct,
with a Java equivalent:

#+begin_example

 Emacs Lisp                             Java
 (condition-case nil                    try {
     (progn                                 doSomething();
       (do-something)                       doSomethingElse();
       (do-something-else))                     } catch (Throwable t) {
   (error                                       print("uh-oh");
    (message "oh no!")                          doRecoveryStuff();
    (do-recovery-stuff)))                        }
#+end_example

If you want an empty catch block (just squelch the error), you can use
ignore-errors:
(ignore-errors
  (do-something)
  (do-something-else))

It's sometimes a good idea to slap an ignore-errors around bits of elisp code in
your startup file that may not always work, so you can still at least start your
Emacs up if the code is failing.

The condition-case nil means "Don't assign the error to a named variable." Elisp
lets you catch different kinds of errors and examine the error data. You can
read the Emacs manual or Info pages to learn more about how to do that.

The progn is necessary if you have multiple expressions (in C/Java, statements)
to evaluate in the condition-case body.

condition-case will not catch values thrown by throw – the two systems are
independent.

*** try/finally

Emacs has a "finally"-like facility called unwind-protect.

#+begin_example

 Emacs Lisp                             Java
 (unwind-protect                          try {
     (progn                                 doSomething();
       (do-something)                      doSomethingElse();
       (do-something-else))              } finally {
   (first-finally-expr)                 firstFinallyExpr();
   (second-finally-expr))               secondFinallyExpr();
                                        }
#+end_example

Like condition-case, unwind-protect takes a single body-form followed by one or
more cleanup forms, so you need to use progn if you have more than one
expression in the body.

*** try/catch/finally

If you make the condition-case (which is basically try/catch) the body-form of
an unwind-protect (which is basically try/finally), you get the effect of
try/catch/finally:

#+BEGIN_SRC
(unwind-protect                 ; finally
    (condition-case nil         ; try
        (progn                  ; {
          (do-something)        ;   body-1
          (do-something-else))  ;   body-2 }
      (error                    ; catch
       (message "oh no!")       ; { catch 1
       (poop-pants)))           ;   catch 2 }
  (first-finally-expr)          ; { finally 1
  (second-finally-expr))        ;   finally 2 }
#+END_SRC

*** Classes

Emacs Lisp is not object-oriented in the standard sense: it doesn't have
classes, inheritance, polymorphism and so on. The Common Lisp package includes a
useful feature called defstruct that gives you some simple OOP-like support.
I'll walk through a basic example.

These two declarations are essentially equivalent:

#+begin_example


 Emacs Lisp                                                             Java
 (require 'cl) ; top of file                                            /* A Person class */
                                                                        class Person {
 (defstruct person                                                      String name;
   "A person structure."                                                int age;
   name                                                                 double height;
   (age 0)                                                              public Person() {}
   (height 0.0))                                                        public Person(String name) {
                                                                          this(name, 0, 0);
                                                                        }
                                                                        public Person(int age) {
                                                                          this(null, age, 0);
                                                                        }
                                                                        public Person(double height) {
                                                                          this(null, 0, height);
                                                                        }
                                                                        public Person(String name, int age) {
                                                                          this(name, age, 0);
                                                                        }
                                                                        public Person(String name, double height) {
                                                                          this(name, 0, height);
                                                                        }
                                                                        public Person(int age, double height) {
                                                                          this(null, age, height);
                                                                        }
                                                                        public Person(String name, int age, double height) {
                                                                          this.name = name;
                                                                          this.age = age;
                                                                          this.height = height;
                                                                        }
                                                                        }



#+end_example


Both create a "class" with three named fields, and constructors for initializing
any subset of the fields. With defstruct you get one constructor with keyword
parameters, so these are all valid:
(make-person)  ; new Person()
(make-person :age 39)  ; new Person(39)
(make-person :name "Steve" :height 5.83 :age 39)  ; new Person("Steve", 39, 5.83)

#+begin_example

 Emacs Lisp                             Java
 (defstruct (employee                   /* An Employee class */
             (:include person))         class Employee extends Person {
   "An employee structure."             String company;
   company                              int level = 1;
   (level 1)                            String title = "n00b";
   (title "n00b"))                      public Employee() {
                                        }
                                        public Employee(String name,
                                                        String company) {
                                                                                  super(name);
                                          this.company = company;
                                        }
                                        public Employee(String name,
                                                        int age,
                                                        String company) {
                                          super(name, age);
                                          this.company = company;
                                        }
                                        public Employee(String name,
                                                        int age,
                                                        double height,
                                                        String company) {
                                          super(name, age, height);
                                          this.company = company;
                                        }
                                        public Employee(String name,
                                                        int age,
                                                        String company,
                                                        int level) {
                                          super(name, age);
                                          this.company = company;
                                          this.level = level;
                                        }
                                        public Employee(String name,
                                                        int age,
                                                        String co,
                                                        int lvl,
                                                        String title) {
                                          super(name, age);
                                          this.company = co;
                                          this.level = lvl;
                                          this.title = title;
                                        }
                                        // (remaining 150 overloaded constructors elided for brevity)
                                     }
#+end_example

The defstruct macro supports single-inheritance (to arbitrary depth):

The defstruct macro provides a flexible default constructor, but also gives you
a fair amount of control over your constructor(s) if you prefer.

The defstruct macro creates an instanceof-like predicate function named after
the struct, so you can say:

#+BEGIN_SRC
(person-p (make-person))
t
(employee-p (make-person))
nil
(employee-p (make-employee))
t
(person-p (make-employee))  ; yes, it inherits from person
t
#+END_SRC

Java may suck at declaring constructors, but Emacs Lisp makes up for it by
sucking at setting fields. To set a field in a struct, you have to use the setf
function, and construct the field name by prepending the structure name. So:

#+begin_example


 Emacs Lisp                             Java
 (setq e (make-employee))               Employee e = new Employee();
 (setf (employee-name e) "Steve"                e.name = "Steve";
       (employee-age e) 39                      e.age = 39;
       (employee-company e) "Google"            e.company = "Google";
       (employee-title e) "Janitor")            e.title = "Janitor";
#+end_example

The Lisp one doesn't look too bad here, but in practice (because Elisp has no
namespace support and no with-slots macro), you wind up with long structure and
field names. So your defstruct-enabled elisp code tends to look more like this:
(setf (js2-compiler-data-current-script-or-function compiler-data) current-script
      (js2-compiler-data-line-number compiler-data) current-line
      (js2-compiler-data-allow-member-expr-as-function-name compiler-data) allow
      (js2-compiler-data-language-version compiler-data) language-version)
So it goes.

To fetch the value of a field in a struct variable, you concatenate the struct
name with the field name and use it as a function call:

(person-name steve)  ; yields "Steve"

There's more that defstruct can do – it's a pretty decent facility, all things
considered, though it falls well short of a full object system.

*** Buffers as classes

In Elisp programming it can often be useful to think of buffers as instances of
your own classes. This is because Emacs supports the notion of buffer-local
variables: variables that automatically become buffer-local whenever they are
set in any fashion. They become part of the scope chain for any code executing
in the buffer, so they act a lot like encapsulated instance variables.

You can use the function make-variable-buffer-local to declare a variable as
buffer-local. Usually it comes right after the defvar or defconst declaration
(see below.)

*** Variables

You can declare a variable, optionally giving it some runtime documentation,
with defvar or defconst:
(defconst pi 3.14159 "A gross approximation of pi.")
The syntax is (defvar name value [ doc-string ]).

Ironically, defconst is variable and defvar is constant, at least if you
re-evaluate them. To change the value of a defvar variable by re-evaluating its
declaration you need to use makunbound to unbind it first. You can always change
the value of any defvar or defconst variable using setq. The only difference
between the two is that defconst makes it clearer to the programmer that the
value is not intended to change.

You can use setq to create brand-new variables, but if you use defvar, the
byte-compiler will be able to catch more typos.

*** Further reading

Emacs Lisp is a real programming language. It has a compiler, a debugger, a
profiler, pretty-printers, runtime documentation, libraries, I/O, networking,
process control and much more. There's a lot to learn, but I'm hoping this
little primer has got you over the hump, as it were.

In spite of its various quirks and annoyances, Elisp is reasonably fun to
program in once you get the hang of it. As a language it's not that great, and
everyone wishes it were Common Lisp or Scheme or some other reasonable Lisp
dialect. Some people even wish it weren't Lisp at all, if you can believe that!
(hee)

But it's really, really useful to be able to customize your editor, and also to
be able to fix problems with elisp code you borrowed or inherited. So a little
Elisp goes a long way.

For those of you learning Emacs Lisp, please let me know if you found this
useful. If you try writing some Emacs extensions, let me know what you would
like to see documented next; I can always do another installment of the
Emergency Elisp series if there's enough interest.

Good luck!

* [[https://unix.stackexchange.com/a/151046][x11 - CapsLock as modifier key for application keymaps - Unix & Linux Stack Exchange]] :website:

[2020-04-24 Fri 16:58]

** Article


*** 2 Answers 2


There are a bajillion answers on the internet, most of them confusing.

The key is you need to map 'keycode 66' to your hyper key, remove the mapping of that key from other mod{1,2,4,5}'s (only if present), and then set mod3.

Open ~/.Xmodmap and put the following:

#+BEGIN_EXAMPLE
  ! Unmap capslock
  clear Lock
  keycode 66 = Hyper_L

  ! Leave mod4 as windows key _only_
  remove mod4 = Hyper_L

  ! Set mod3 to capslock
  add mod3 = Hyper_L
#+END_EXAMPLE

Run this

#+BEGIN_EXAMPLE
   xmodmap ~/.Xmodmap
#+END_EXAMPLE

If something goes wrong, you can reset your keyboard with:

#+BEGIN_EXAMPLE
   setxkbmap -layout us
#+END_EXAMPLE

Likely causes of something exploding are that Hyper_L is mapped someplace else. Fix this by running xmodmap without args to figure out what else is bound to Hyper_L. When you know what you need to remove, chuck a 'remove BINDING = Hyper_L' in your .Xmodmap file.

The .Xmodmap file will be loaded in when you open X11 sessions, you should have this mapping in place next time you login or reboot.

This configuration works for my ubuntu 14.04 setup. If you have a different *nix and this doesn't work, please post what you did to get around it here and I'll incorporate it into the answer.
